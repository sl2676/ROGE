/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /home/sean/gem5-rtl/src/mem/slicc/symbols/Type.py:836
 */

#include <cassert>
#include <iostream>
#include <string>

#include "base/logging.hh"
#include "mem/ruby/protocol/Memory_Event.hh"

namespace gem5
{

namespace ruby
{

// Code for output operator
::std::ostream&
operator<<(::std::ostream& out, const Memory_Event& obj)
{
    out << Memory_Event_to_string(obj);
    out << ::std::flush;
    return out;
}

// Code to convert state to a string
std::string
Memory_Event_to_string(const Memory_Event& obj)
{
    switch(obj) {
      case Memory_Event_CheckAllocTBE:
        return "CheckAllocTBE";
      case Memory_Event_CheckAllocTBE_WithCredit:
        return "CheckAllocTBE_WithCredit";
      case Memory_Event_WriteNoSnpPtl:
        return "WriteNoSnpPtl";
      case Memory_Event_WriteNoSnp:
        return "WriteNoSnp";
      case Memory_Event_ReadNoSnp:
        return "ReadNoSnp";
      case Memory_Event_ReadNoSnpSep:
        return "ReadNoSnpSep";
      case Memory_Event_WriteData:
        return "WriteData";
      case Memory_Event_MemoryData:
        return "MemoryData";
      case Memory_Event_MemoryAck:
        return "MemoryAck";
      case Memory_Event_Trigger_Send:
        return "Trigger_Send";
      case Memory_Event_Trigger_SendDone:
        return "Trigger_SendDone";
      case Memory_Event_Trigger_ReceiveDone:
        return "Trigger_ReceiveDone";
      case Memory_Event_Trigger_SendRetry:
        return "Trigger_SendRetry";
      case Memory_Event_Trigger_SendPCrdGrant:
        return "Trigger_SendPCrdGrant";
      default:
        panic("Invalid range for type Memory_Event");
    }
    // Appease the compiler since this function has a return value
    return "";
}

// Code to convert from a string to the enumeration
Memory_Event
string_to_Memory_Event(const std::string& str)
{
    if (str == "CheckAllocTBE") {
        return Memory_Event_CheckAllocTBE;
    } else if (str == "CheckAllocTBE_WithCredit") {
        return Memory_Event_CheckAllocTBE_WithCredit;
    } else if (str == "WriteNoSnpPtl") {
        return Memory_Event_WriteNoSnpPtl;
    } else if (str == "WriteNoSnp") {
        return Memory_Event_WriteNoSnp;
    } else if (str == "ReadNoSnp") {
        return Memory_Event_ReadNoSnp;
    } else if (str == "ReadNoSnpSep") {
        return Memory_Event_ReadNoSnpSep;
    } else if (str == "WriteData") {
        return Memory_Event_WriteData;
    } else if (str == "MemoryData") {
        return Memory_Event_MemoryData;
    } else if (str == "MemoryAck") {
        return Memory_Event_MemoryAck;
    } else if (str == "Trigger_Send") {
        return Memory_Event_Trigger_Send;
    } else if (str == "Trigger_SendDone") {
        return Memory_Event_Trigger_SendDone;
    } else if (str == "Trigger_ReceiveDone") {
        return Memory_Event_Trigger_ReceiveDone;
    } else if (str == "Trigger_SendRetry") {
        return Memory_Event_Trigger_SendRetry;
    } else if (str == "Trigger_SendPCrdGrant") {
        return Memory_Event_Trigger_SendPCrdGrant;
    } else {
        panic("Invalid string conversion for %s, type Memory_Event", str);
    }
}

// Code to increment an enumeration type
Memory_Event&
operator++(Memory_Event& e)
{
    assert(e < Memory_Event_NUM);
    return e = Memory_Event(e+1);
}
} // namespace ruby
} // namespace gem5
