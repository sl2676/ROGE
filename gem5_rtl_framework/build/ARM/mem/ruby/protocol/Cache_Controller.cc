/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /home/sean/gem5-rtl/src/mem/slicc/symbols/StateMachine.py:1225
 */

// Created by slicc definition of Module "Cache coherency protocol"

#include <sys/types.h>
#include <unistd.h>

#include <cassert>
#include <sstream>
#include <string>
#include <typeinfo>

#include "mem/ruby/common/BoolVec.hh"

#include "base/compiler.hh"
#include "base/cprintf.hh"

#include "debug/RubySlicc.hh"
#include "debug/LLSC.hh"
#include "debug/RubyGenerated.hh"
#include "mem/ruby/network/Network.hh"
#include "mem/ruby/protocol/Cache_Controller.hh"
#include "mem/ruby/protocol/Cache_Event.hh"
#include "mem/ruby/protocol/Cache_State.hh"
#include "mem/ruby/protocol/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#include "mem/ruby/slicc_interface/RubySlicc_includes.hh"
#include "mem/ruby/protocol/PerfectCacheMemory.hh"
#include "mem/ruby/protocol/TimerTable.hh"
#include "mem/ruby/protocol/TBETable.hh"
#include "mem/ruby/protocol/TBEStorage.hh"
#include "mem/ruby/protocol/TriggerQueue.hh"
#include "mem/ruby/protocol/NetDest.hh"
namespace gem5
{

namespace ruby
{

int Cache_Controller::m_num_controllers = 0;
std::vector<statistics::Vector *>  Cache_Controller::eventVec;
std::vector<std::vector<statistics::Vector *> >  Cache_Controller::transVec;

// for adding information to the protocol debug trace
std::stringstream Cache_transitionComment;

#ifndef NDEBUG
#define APPEND_TRANSITION_COMMENT(str) (Cache_transitionComment << str)
#else
#define APPEND_TRANSITION_COMMENT(str) do {} while (0)
#endif

/** \brief constructor */
Cache_Controller::Cache_Controller(const Params &p)
    : AbstractController(p)
{
    m_machineID.type = MachineType_Cache;
    m_machineID.num = m_version;
    m_num_controllers++;
    p.ruby_system->registerAbstractController(this);

    m_in_ports = 12;
    m_sequencer_ptr = p.sequencer;
    if (m_sequencer_ptr != NULL) {
        m_sequencer_ptr->setController(this);
    }
    m_cache_ptr = p.cache;
    m_read_hit_latency = p.read_hit_latency;
    m_read_miss_latency = p.read_miss_latency;
    m_write_fe_latency = p.write_fe_latency;
    m_write_be_latency = p.write_be_latency;
    m_fill_latency = p.fill_latency;
    m_snp_latency = p.snp_latency;
    m_snp_inv_latency = p.snp_inv_latency;
    m_wait_for_cache_wr = p.wait_for_cache_wr;
    m_allocation_latency = p.allocation_latency;
    m_request_latency = p.request_latency;
    m_response_latency = p.response_latency;
    m_snoop_latency = p.snoop_latency;
    m_data_latency = p.data_latency;
    m_sc_lock_base_latency_cy = p.sc_lock_base_latency_cy;
    m_sc_lock_multiplier_inc = p.sc_lock_multiplier_inc;
    m_sc_lock_multiplier_decay = p.sc_lock_multiplier_decay;
    m_sc_lock_multiplier_max = p.sc_lock_multiplier_max;
    m_sc_lock_enabled = p.sc_lock_enabled;
    m_stall_recycle_lat = p.stall_recycle_lat;
    m_send_evictions = p.send_evictions;
    m_number_of_snoop_TBEs = p.number_of_snoop_TBEs;
    m_number_of_repl_TBEs = p.number_of_repl_TBEs;
    m_unify_repl_TBEs = p.unify_repl_TBEs;
    m_dealloc_wait_for_tag = p.dealloc_wait_for_tag;
    m_data_channel_size = p.data_channel_size;
    m_is_HN = p.is_HN;
    m_enable_DMT = p.enable_DMT;
    m_enable_DMT_early_dealloc = p.enable_DMT_early_dealloc;
    m_enable_DCT = p.enable_DCT;
    m_comp_wu = p.comp_wu;
    m_comp_wu_latency = p.comp_wu_latency;
    m_alloc_on_readshared = p.alloc_on_readshared;
    m_alloc_on_readunique = p.alloc_on_readunique;
    m_alloc_on_readonce = p.alloc_on_readonce;
    m_alloc_on_writeback = p.alloc_on_writeback;
    m_alloc_on_seq_acc = p.alloc_on_seq_acc;
    m_alloc_on_seq_line_write = p.alloc_on_seq_line_write;
    m_dealloc_on_unique = p.dealloc_on_unique;
    m_dealloc_on_shared = p.dealloc_on_shared;
    m_dealloc_backinv_unique = p.dealloc_backinv_unique;
    m_dealloc_backinv_shared = p.dealloc_backinv_shared;
    m_fwd_unique_on_readshared = p.fwd_unique_on_readshared;
    m_allow_SD = p.allow_SD;
    m_throttle_req_on_retry = p.throttle_req_on_retry;
    m_use_prefetcher = p.use_prefetcher;
    m_reqOut_ptr = p.reqOut;
    m_snpOut_ptr = p.snpOut;
    m_rspOut_ptr = p.rspOut;
    m_datOut_ptr = p.datOut;
    m_reqIn_ptr = p.reqIn;
    m_snpIn_ptr = p.snpIn;
    m_rspIn_ptr = p.rspIn;
    m_datIn_ptr = p.datIn;
    m_mandatoryQueue_ptr = p.mandatoryQueue;
    m_triggerQueue_ptr = p.triggerQueue;
    m_retryTriggerQueue_ptr = p.retryTriggerQueue;
    m_reqRdy_ptr = p.reqRdy;
    m_snpRdy_ptr = p.snpRdy;
    m_replTriggerQueue_ptr = p.replTriggerQueue;
    m_prefetchQueue_ptr = p.prefetchQueue;
    m_upstream_prefetch_trains_prefetcher = p.upstream_prefetch_trains_prefetcher;

    for (int state = 0; state < Cache_State_NUM; state++) {
        for (int event = 0; event < Cache_Event_NUM; event++) {
            m_possible[state][event] = false;
            m_counters[state][event] = 0;
        }
    }
    for (int event = 0; event < Cache_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }
}

void
Cache_Controller::initNetQueues()
{
    MachineType machine_type = string_to_MachineType("Cache");
    GEM5_VAR_USED int base = MachineType_base_number(machine_type);

    assert(m_reqOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_reqOut_ptr->getOrdered(), 0,
                                     "none", m_reqOut_ptr);
    assert(m_snpOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_snpOut_ptr->getOrdered(), 1,
                                     "none", m_snpOut_ptr);
    assert(m_rspOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_rspOut_ptr->getOrdered(), 2,
                                     "none", m_rspOut_ptr);
    assert(m_datOut_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_datOut_ptr->getOrdered(), 3,
                                     "response", m_datOut_ptr);
    assert(m_reqIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_reqIn_ptr->getOrdered(), 0,
                                     "none", m_reqIn_ptr);
    assert(m_snpIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_snpIn_ptr->getOrdered(), 1,
                                     "none", m_snpIn_ptr);
    assert(m_rspIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_rspIn_ptr->getOrdered(), 2,
                                     "none", m_rspIn_ptr);
    assert(m_datIn_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_datIn_ptr->getOrdered(), 3,
                                     "response", m_datIn_ptr);
}

void
Cache_Controller::init()
{
    // initialize objects
    m_blockSize_ptr = new int;
    (*m_blockSize_ptr) = RubySystem::getBlockSizeBytes();
    m_directory_ptr  = new PerfectCacheMemory<Cache_DirEntry>();
    assert(m_directory_ptr != NULL);
    m_useTimerTable_ptr  = new TimerTable();
    assert(m_useTimerTable_ptr != NULL);
    m_sc_lock_multiplier_ptr = new int;
    (*m_sc_lock_multiplier_ptr) = 0;
    m_TBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_TBEs);
    assert(m_TBEs_ptr != NULL);
    m_storTBEs_ptr  = new TBEStorage(this, m_number_of_TBEs);
    assert(m_storTBEs_ptr != NULL);
    m_replTBEs_ptr  = new TBETable<Cache_TBE>(m_unify_repl_TBEs ? m_number_of_TBEs : m_number_of_repl_TBEs);
    assert(m_replTBEs_ptr != NULL);
    m_storReplTBEs_ptr  = new TBEStorage(this, m_number_of_repl_TBEs);
    assert(m_storReplTBEs_ptr != NULL);
    m_snpTBEs_ptr  = new TBETable<Cache_TBE>(m_number_of_snoop_TBEs);
    assert(m_snpTBEs_ptr != NULL);
    m_storSnpTBEs_ptr  = new TBEStorage(this, m_number_of_snoop_TBEs);
    assert(m_storSnpTBEs_ptr != NULL);
    m_retryQueue_ptr  = new TriggerQueue<Cache_RetryQueueEntry>();
    assert(m_retryQueue_ptr != NULL);
    m_destsWaitingRetry_ptr  = new NetDest();
    assert(m_destsWaitingRetry_ptr != NULL);


    (*m_useTimerTable_ptr).setConsumer(this);
    (*m_rspIn_ptr).setConsumer(this);
    (*m_datIn_ptr).setConsumer(this);
    (*m_snpRdy_ptr).setConsumer(this);
    (*m_snpIn_ptr).setConsumer(this);
    (*m_retryTriggerQueue_ptr).setConsumer(this);
    (*m_triggerQueue_ptr).setConsumer(this);
    (*m_replTriggerQueue_ptr).setConsumer(this);
    (*m_reqRdy_ptr).setConsumer(this);
    (*m_reqIn_ptr).setConsumer(this);
    (*m_mandatoryQueue_ptr).setConsumer(this);
    (*m_prefetchQueue_ptr).setConsumer(this);

    possibleTransition(Cache_State_I, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocRequestWithCredit);
    possibleTransition(Cache_State_I, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RUSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_RUSC, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendRetryAck);
    possibleTransition(Cache_State_I, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RUSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_RUSC, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendPCrdGrant);
    possibleTransition(Cache_State_I, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocSnoop);
    possibleTransition(Cache_State_UD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocSeqRequest);
    possibleTransition(Cache_State_I, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_T, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RUSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UC_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RU, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_RUSC, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_AllocPfRequest);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_TagArrayRead);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TagArrayRead);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_TagArrayWrite);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TagArrayWrite);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayRead);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayRead);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CheckCacheFill);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckCacheFill);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayWrite);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayWrite);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataArrayWriteOnFill);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataArrayWriteOnFill);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadHitPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadHitPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadMissPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadMissPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteFEPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteFEPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBEPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBEPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_FillPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FillPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpSharedPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpSharedPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpInvPipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpInvPipe);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOncePipe);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOncePipe);
    possibleTransition(Cache_State_I, Cache_Event_ReadShared);
    possibleTransition(Cache_State_I, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RU, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RU, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_I, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RU, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_I, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_I, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RU, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_I, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_SD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_I, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_RU, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_I, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_UD, Cache_Event_Load);
    possibleTransition(Cache_State_UD_T, Cache_Event_Load);
    possibleTransition(Cache_State_SD, Cache_Event_Load);
    possibleTransition(Cache_State_UC, Cache_Event_Load);
    possibleTransition(Cache_State_SC, Cache_Event_Load);
    possibleTransition(Cache_State_UD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_T, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_RUSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_LoadHit);
    possibleTransition(Cache_State_UD, Cache_Event_Store);
    possibleTransition(Cache_State_UD_T, Cache_Event_Store);
    possibleTransition(Cache_State_UC, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_StoreHit);
    possibleTransition(Cache_State_I, Cache_Event_Load);
    possibleTransition(Cache_State_I, Cache_Event_Prefetch);
    possibleTransition(Cache_State_I, Cache_Event_Store);
    possibleTransition(Cache_State_SD, Cache_Event_Store);
    possibleTransition(Cache_State_SC, Cache_Event_Store);
    possibleTransition(Cache_State_UD_T, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_UseTimeout);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_RSC, Cache_Event_Evict);
    possibleTransition(Cache_State_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_RUSD, Cache_Event_Evict);
    possibleTransition(Cache_State_RUSC, Cache_Event_Evict);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Evict);
    possibleTransition(Cache_State_UD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_I, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_RU, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RUSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RUSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_RSC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UD_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC_RU, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_UC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_I, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_SC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_SC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_RU, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UC_RU, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_RU, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RU, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RSC, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RSC, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_RUSD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_RUSD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_I, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RU, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RU, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RU, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpShared);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpShared);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_UD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UD_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SD_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_UC_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_SC_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RU, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RU, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RUSD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_RUSC, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Load);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Evict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadShared);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadNotSharedDirty);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadUnique_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadOnce);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CleanUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Load);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Store);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Prefetch);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBackFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteBackFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteEvictFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteEvictFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteCleanFull);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteCleanFull_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Evict);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Evict_Stale);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUnique);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniquePtl_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniqueFull_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WriteUniqueFull_PoC_Alloc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_Global_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_Local_Eviction);
    possibleTransition(Cache_State_UD_T, Cache_Event_LocalHN_Eviction);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpStalled);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SnpStalled);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpCleanInvalid);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpShared);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpUnique);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpSharedFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpUniqueFwd);
    possibleTransition(Cache_State_UD_T, Cache_Event_SnpNotSharedDirtyFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_ActionStalledOnHazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ActionStalledOnHazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteBackOrWriteEvict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteClean);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteNoSnp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWriteNoSnpPartial);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendEvict);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWBData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWUData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendWUDataCB);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendInvSnpResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpNotSharedDirtyFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnceFwdCompData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpFwdedData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpFwdedResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpIResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompIResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompUCResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendRespSepData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_WaitCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_WaitCompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RestoreFromHazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadNoSnp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendReadNoSnpDMT);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpShared);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdToOwner);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpSharedFwdToSharer);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnceFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpOnce);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueRetToSrc);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpUniqueFwd);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpCleanInvalid);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendSnpCleanInvalidNoReq);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDResp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendDBIDResp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendComp_WU);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_SendComp_WU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SendCompDBIDRespStale);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_MaintainCoherence);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_FinishCleanUnique);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromStore);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromCU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CheckUpgrade_FromRU);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CBWrData_UD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_NCBWrData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_NCBWrData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_UD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_SC_PD_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_PD_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpRespData_I_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RespSepData);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RespSepData);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DataSepResp_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DataSepResp_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompData_UD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_SC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_SD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompData_UD_PD);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_ReadReceipt);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_PoC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_PoC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_RetryAck_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_RetryAck_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_PCrdGrant_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_PCrdGrant_PoC_Hazard);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DoRetry);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DoRetry);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DoRetry_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_DoRetry_Hazard);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_CompAck);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompAck);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I_Fwded_UC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_I_Fwded_UD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_SC);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_SD_PD);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_UC_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_UD_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SC_Fwded_I);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_SnpResp_SD_Fwded_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_CompDBIDResp);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Comp_I);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Comp_UC);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_DBIDResp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Comp);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_TX_Data);
    possibleTransition(Cache_State_BUSY_BLKD, Cache_Event_Final);
    possibleTransition(Cache_State_BUSY_INTR, Cache_Event_Final);
    AbstractController::init();
    resetStats();
}
Sequencer*
Cache_Controller::getCPUSequencer() const
{
    if (NULL != m_sequencer_ptr && m_sequencer_ptr->isCPUSequencer()) {
        return m_sequencer_ptr;
    } else {
        return NULL;
    }
}

DMASequencer*
Cache_Controller::getDMASequencer() const
{
    return NULL;
}

GPUCoalescer*
Cache_Controller::getGPUCoalescer() const
{
    return NULL;
}

void
Cache_Controller::regStats()
{
    AbstractController::regStats();

    // For each type of controllers, one controller of that type is picked
    // to aggregate stats of all controllers of that type. 
    if (m_version == 0) {

        Profiler *profiler = params().ruby_system->getProfiler();
        statistics::Group *profilerStatsPtr = &profiler->rubyProfilerStats;

        for (Cache_Event event = Cache_Event_FIRST;
             event < Cache_Event_NUM; ++event) {
            std::string stat_name =
                "Cache_Controller." + Cache_Event_to_string(event);
            statistics::Vector *t =
                new statistics::Vector(profilerStatsPtr, stat_name.c_str());
            t->init(m_num_controllers);
            t->flags(statistics::pdf | statistics::total |
                statistics::oneline | statistics::nozero);

            eventVec.push_back(t);
        }

        for (Cache_State state = Cache_State_FIRST;
             state < Cache_State_NUM; ++state) {

            transVec.push_back(std::vector<statistics::Vector *>());

            for (Cache_Event event = Cache_Event_FIRST;
                 event < Cache_Event_NUM; ++event) {
                std::string stat_name = "Cache_Controller." +
                    Cache_State_to_string(state) +
                    "." + Cache_Event_to_string(event);
                statistics::Vector *t = new statistics::Vector(
                    profilerStatsPtr, stat_name.c_str());
                t->init(m_num_controllers);
                t->flags(statistics::pdf | statistics::total |
                    statistics::oneline | statistics::nozero);
                transVec[state].push_back(t);
            }
        }
    }

    for (Cache_Event event = Cache_Event_FIRST;
                 event < Cache_Event_NUM; ++event) {
        std::string stat_name =
            "outTransLatHist." + Cache_Event_to_string(event);
        statistics::Histogram* t =
            new statistics::Histogram(&stats, stat_name.c_str());
        stats.outTransLatHist.push_back(t);
        t->init(5);
        t->flags(statistics::pdf | statistics::total |
                 statistics::oneline | statistics::nozero);

        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".retries").c_str());
        stats.outTransLatHistRetries.push_back(r);
        r->flags(statistics::nozero);
    }

    for (Cache_Event event = Cache_Event_FIRST;
                 event < Cache_Event_NUM; ++event) {
        std::string stat_name = "inTransLatHist." +
                                Cache_Event_to_string(event);
        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".total").c_str());
        stats.inTransLatTotal.push_back(r);
        r->flags(statistics::nozero);

        r = new statistics::Scalar(&stats,
                              (stat_name + ".retries").c_str());
        stats.inTransLatRetries.push_back(r);
        r->flags(statistics::nozero);

        stats.inTransLatHist.emplace_back();
        for (Cache_State initial_state = Cache_State_FIRST;
             initial_state < Cache_State_NUM; ++initial_state) {
            stats.inTransLatHist.back().emplace_back();
            for (Cache_State final_state = Cache_State_FIRST;
                 final_state < Cache_State_NUM; ++final_state) {
                std::string stat_name = "inTransLatHist." +
                    Cache_Event_to_string(event) + "." +
                    Cache_State_to_string(initial_state) + "." +
                    Cache_State_to_string(final_state);
                statistics::Histogram* t =
                    new statistics::Histogram(&stats, stat_name.c_str());
                stats.inTransLatHist.back().back().push_back(t);
                t->init(5);
                t->flags(statistics::pdf | statistics::total |
                         statistics::oneline | statistics::nozero);
            }
        }
    }
}

void
Cache_Controller::collateStats()
{
    for (Cache_Event event = Cache_Event_FIRST;
         event < Cache_Event_NUM; ++event) {
        for (unsigned int i = 0; i < m_num_controllers; ++i) {
            RubySystem *rs = params().ruby_system;
            std::map<uint32_t, AbstractController *>::iterator it =
                     rs->m_abstract_controls[MachineType_Cache].find(i);
            assert(it != rs->m_abstract_controls[MachineType_Cache].end());
            (*eventVec[event])[i] =
                ((Cache_Controller *)(*it).second)->getEventCount(event);
        }
    }

    for (Cache_State state = Cache_State_FIRST;
         state < Cache_State_NUM; ++state) {

        for (Cache_Event event = Cache_Event_FIRST;
             event < Cache_Event_NUM; ++event) {

            for (unsigned int i = 0; i < m_num_controllers; ++i) {
                RubySystem *rs = params().ruby_system;
                std::map<uint32_t, AbstractController *>::iterator it =
                         rs->m_abstract_controls[MachineType_Cache].find(i);
                assert(it != rs->m_abstract_controls[MachineType_Cache].end());
                (*transVec[state][event])[i] =
                    ((Cache_Controller *)(*it).second)->getTransitionCount(state, event);
            }
        }
    }
}

void
Cache_Controller::countTransition(Cache_State state, Cache_Event event)
{
    assert(m_possible[state][event]);
    m_counters[state][event]++;
    m_event_counters[event]++;
}
void
Cache_Controller::possibleTransition(Cache_State state,
                             Cache_Event event)
{
    m_possible[state][event] = true;
}

uint64_t
Cache_Controller::getEventCount(Cache_Event event)
{
    return m_event_counters[event];
}

bool
Cache_Controller::isPossible(Cache_State state, Cache_Event event)
{
    return m_possible[state][event];
}

uint64_t
Cache_Controller::getTransitionCount(Cache_State state,
                             Cache_Event event)
{
    return m_counters[state][event];
}

int
Cache_Controller::getNumControllers()
{
    return m_num_controllers;
}

MessageBuffer*
Cache_Controller::getMandatoryQueue() const
{
    return m_mandatoryQueue_ptr;
}

MessageBuffer*
Cache_Controller::getMemReqQueue() const
{
    return NULL;
}

MessageBuffer*
Cache_Controller::getMemRespQueue() const
{
    return NULL;
}

void
Cache_Controller::print(std::ostream& out) const
{
    out << "[Cache_Controller " << m_version << "]";
}

void Cache_Controller::resetStats()
{
    for (int state = 0; state < Cache_State_NUM; state++) {
        for (int event = 0; event < Cache_Event_NUM; event++) {
            m_counters[state][event] = 0;
        }
    }

    for (int event = 0; event < Cache_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }

    AbstractController::resetStats();
}

// Set and Reset for cache_entry variable
void
Cache_Controller::set_cache_entry(Cache_CacheEntry*& m_cache_entry_ptr, AbstractCacheEntry* m_new_cache_entry)
{
  m_cache_entry_ptr = (Cache_CacheEntry*)m_new_cache_entry;
}

void
Cache_Controller::unset_cache_entry(Cache_CacheEntry*& m_cache_entry_ptr)
{
  m_cache_entry_ptr = 0;
}

// Set and Reset for tbe variable
void
Cache_Controller::set_tbe(Cache_TBE*& m_tbe_ptr, Cache_TBE* m_new_tbe)
{
  m_tbe_ptr = m_new_tbe;
}

void
Cache_Controller::unset_tbe(Cache_TBE*& m_tbe_ptr)
{
  m_tbe_ptr = NULL;
}

void
Cache_Controller::recordCacheTrace(int cntrl, CacheRecorder* tr)
{
    m_cache_ptr->recordCacheContents(cntrl, tr);
}

// Actions
/** \brief  */
void
Cache_Controller::AllocateTBE_Request(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request\n");
    try {
           if ((((*m_storTBEs_ptr)).areNSlotsAvailable((1)))) {
        (((*m_storTBEs_ptr)).incrementReserved());
        {
            // Declare message
            GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            #ifndef NDEBUG
            if (!((((*in_msg_ptr)).m_addr == addr))) {
                panic("Runtime Error at CHI-cache-actions.sm:51: %s.\n", "assert failure");

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!((((*in_msg_ptr)).m_is_local_pf == (false)))) {
                panic("Runtime Error at CHI-cache-actions.sm:52: %s.\n", "assert failure");

            }
            #endif
            ;
            *out_msg = (*in_msg_ptr);
            ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
        }
        }
    } else {
        {
            // Declare message
            GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!(((*in_msg_ptr)).m_allowRetry)) {
            panic("Runtime Error at CHI-cache-actions.sm:60: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
            (*out_msg).m_event = Cache_Event_SendRetryAck;
            (*out_msg).m_retryDest = ((*in_msg_ptr)).m_requestor;
            (((*m_retryQueue_ptr)).emplace(((*in_msg_ptr)).m_addr, ((*in_msg_ptr)).m_requestor));
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
        }
    }
    (((*m_reqIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Request: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_Request_WithCredit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Request_WithCredit\n");
    try {
       {
    // Declare message
    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_allowRetry == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:77: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:79: %s.\n", "assert failure");

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
}
}
(((*m_reqIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Request_WithCredit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_Snoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_Snoop\n");
    try {
       (((*m_storSnpTBEs_ptr)).incrementReserved());
{
    // Declare message
    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_addr == addr))) {
        panic("Runtime Error at CHI-cache-actions.sm:95: %s.\n", "assert failure");

    }
    #endif
    ;
    *out_msg = (*in_msg_ptr);
    ((*m_snpRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
}
(((*m_destsWaitingRetry_ptr)).remove(((*in_msg_ptr)).m_requestor));
}
(((*m_snpIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_Snoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::AllocateTBE_SeqRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_SeqRequest\n");
    try {
       (((*m_storTBEs_ptr)).incrementReserved());
{
    // Declare message
    GEM5_VAR_USED const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_mandatoryQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_LineAddress;
    #ifndef NDEBUG
    if (!(((((*in_msg_ptr)).m_Size > (0)) && (((*in_msg_ptr)).m_Size <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:120: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_PhysicalAddress;
    (*out_msg).m_accSize = ((*in_msg_ptr)).m_Size;
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch == PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:127: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (false);
    (*out_msg).m_is_remote_pf = (false);
        if (((((*in_msg_ptr)).m_Type == RubyRequestType_LD) || (((*in_msg_ptr)).m_Type == RubyRequestType_IFETCH))) {
            (*out_msg).m_type = CHIRequestType_Load;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_ST)) {
                        if ((((*in_msg_ptr)).m_Size == (*m_blockSize_ptr))) {
                            (*out_msg).m_type = CHIRequestType_StoreLine;
                        } else {
                            (*out_msg).m_type = CHIRequestType_Store;
                        }
                    } else {
                        panic("Runtime Error at CHI-cache-actions.sm:141: %s.\n", ("Invalid RubyRequestType"));
                        ;
                    }
                }
                ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_allocation_latency)));
            }
            }
            (((*m_mandatoryQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_SeqRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Allocate TBE for prefetch request */
void
Cache_Controller::AllocateTBE_PfRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing AllocateTBE_PfRequest\n");
    try {
       (((*m_storTBEs_ptr)).incrementReserved());
{
    // Declare message
    GEM5_VAR_USED const RubyRequest* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_prefetchQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_LineAddress;
    #ifndef NDEBUG
    if (!(((((*in_msg_ptr)).m_Size > (0)) && (((*in_msg_ptr)).m_Size <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:159: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_accAddr = ((*in_msg_ptr)).m_PhysicalAddress;
    (*out_msg).m_accSize = ((*in_msg_ptr)).m_Size;
    (*out_msg).m_requestor = m_machineID;
    (*out_msg).m_fwdRequestor = m_machineID;
    (*out_msg).m_seqReq = (((*in_msg_ptr)).getRequestPtr());
    (*out_msg).m_isSeqReqValid = (true);
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_Prefetch != PrefetchBit_No))) {
        panic("Runtime Error at CHI-cache-actions.sm:166: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_is_local_pf = (true);
    (*out_msg).m_is_remote_pf = (false);
        if ((((*in_msg_ptr)).m_Type == RubyRequestType_LD)) {
            (*out_msg).m_type = CHIRequestType_Load;
        } else {
                if ((((*in_msg_ptr)).m_Type == RubyRequestType_ST)) {
                    panic("Runtime Error at CHI-cache-actions.sm:173: %s.\n", ("CHI is not supporting prefetch store requests"));
                    ;
                } else {
                    panic("Runtime Error at CHI-cache-actions.sm:175: %s.\n", ("Invalid RubyRequestType"));
                    ;
                }
            }
            ((*m_reqRdy_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
        }
        (((*m_prefetchQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:AllocateTBE_PfRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
bool was_retried
 = (false);
{
    // Declare message
    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateRequestTBE(addr, (*in_msg_ptr))));;
was_retried = (((*in_msg_ptr)).m_allowRetry == (false));
}
Cache_DirEntry* dir_entry
 = (getDirEntry(addr));
(copyCacheAndDir(m_cache_entry_ptr, dir_entry, m_tbe_ptr, initial));
(*m_tbe_ptr).m_use_DMT = (m_is_HN && m_enable_DMT);
(*m_tbe_ptr).m_use_DCT = m_enable_DCT;
bool alloc_entry
 = (needCacheEntry((*m_tbe_ptr).m_reqType, m_cache_entry_ptr, dir_entry, (*m_tbe_ptr).m_is_local_pf));
bool dealloc_entry
 = (needDeallocCacheEntry((*m_tbe_ptr).m_reqType));
#ifndef NDEBUG
if (!(((alloc_entry && dealloc_entry) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:200: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataToBeInvalid = (dealloc_entry || ((m_cache_entry_ptr == NULL) && (alloc_entry == (false))));
(*m_tbe_ptr).m_doCacheFill = (alloc_entry || (m_cache_entry_ptr != NULL));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
(incomingTransactionStart(addr, (curTransitionEvent()), initial, was_retried));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Request_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Request_Stale\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
bool was_retried
 = (false);
{
    // Declare message
    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateRequestTBE(addr, (*in_msg_ptr))));;
was_retried = (((*in_msg_ptr)).m_allowRetry == (false));
}
(copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
(incomingTransactionStart(addr, (curTransitionEvent()), initial, was_retried));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Request_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Snoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Snoop\n");
    try {
       Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
{
    // Declare message
    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateSnoopTBE(addr, (*in_msg_ptr))));;
}
(copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
(*m_tbe_ptr).m_dataToBeInvalid = (m_cache_entry_ptr == NULL);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
(incomingTransactionStart(addr, (curTransitionEvent()), initial, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Snoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Snoop_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Snoop_Hazard\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:242: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_is_req_tbe || (*m_tbe_ptr).m_is_repl_tbe))) {
    panic("Runtime Error at CHI-cache-actions.sm:243: %s.\n", "assert failure");

}
#endif
;
Cache_TBE* prev_tbe
 = m_tbe_ptr;
{
    // Declare message
    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
set_tbe(m_tbe_ptr, (allocateSnoopTBE(addr, (*in_msg_ptr))));;
}
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-actions.sm:250: %s.\n", "assert failure");

}
#endif
;
    if ((*prev_tbe).m_is_req_tbe) {
        #ifndef NDEBUG
        if (!(((*prev_tbe).m_is_repl_tbe == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:252: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_req_hazard = (true);
    } else {
        #ifndef NDEBUG
        if (!((*prev_tbe).m_is_repl_tbe)) {
            panic("Runtime Error at CHI-cache-actions.sm:255: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_is_repl_hazard = (true);
    }
    (*m_tbe_ptr).m_pendReqType = (*prev_tbe).m_pendReqType;
    (copyCacheAndDirTBEs(prev_tbe, m_tbe_ptr));
    (*m_tbe_ptr).m_wakeup_pending_req = (*prev_tbe).m_wakeup_pending_req;
    (*m_tbe_ptr).m_wakeup_pending_snp = (*prev_tbe).m_wakeup_pending_snp;
    (*m_tbe_ptr).m_wakeup_pending_tgr = (*prev_tbe).m_wakeup_pending_tgr;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Snoop_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::RestoreFromHazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing RestoreFromHazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
(setDataToBeStates(m_tbe_ptr));
(copyCacheAndDirTBEs(m_tbe_ptr, hazard_tbe));
(*hazard_tbe).m_wakeup_pending_req = (*m_tbe_ptr).m_wakeup_pending_req;
(*hazard_tbe).m_wakeup_pending_snp = (*m_tbe_ptr).m_wakeup_pending_snp;
(*hazard_tbe).m_wakeup_pending_tgr = (*m_tbe_ptr).m_wakeup_pending_tgr;
(deallocateSnpTBE(m_tbe_ptr));
set_tbe(m_tbe_ptr, hazard_tbe);;
    if (((*m_tbe_ptr).m_pendReqType == CHIRequestType_WriteBackFull)) {
        (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false));
    } else {
            if (((*m_tbe_ptr).m_pendReqType == CHIRequestType_WriteCleanFull)) {
                (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false));
            } else {
                    if (((*hazard_tbe).m_pendReqType == CHIRequestType_WriteEvictFull)) {
                        (*m_tbe_ptr).m_is_stale = (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false));
                    } else {
                            if (((*hazard_tbe).m_pendReqType == CHIRequestType_Evict)) {
                                (*m_tbe_ptr).m_is_stale = ((*m_tbe_ptr).m_dataValid == (false));
                            }
                        }
                    }
                }
                (wakeupPendingTgrs(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:RestoreFromHazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr == NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:299: %s.\n", "assert failure");

}
#endif
;
Cache_State initial
 = (getState(m_tbe_ptr, m_cache_entry_ptr, addr));
    if (m_unify_repl_TBEs) {
        {
            // Declare message
            GEM5_VAR_USED const Cache_ReplacementMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const Cache_ReplacementMsg *>(((*m_replTriggerQueue_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        set_tbe(m_tbe_ptr, (allocateReplacementTBEOnSlot(addr, ((*in_msg_ptr)).m_slot)));;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:304: Allocated replacement TBE on slot %d\n", (*m_tbe_ptr).m_storSlot);
        }
    } else {
        set_tbe(m_tbe_ptr, (allocateReplacementTBE(addr)));;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:308: Allocated replacement TBE on new slot %d\n", (*m_tbe_ptr).m_storSlot);
    }
    (copyCacheAndDir(m_cache_entry_ptr, (getDirEntry(addr)), m_tbe_ptr, initial));
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayRead));
    (incomingTransactionStart(addr, (curTransitionEvent()), initial, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:322: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:323: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_req = (true);
        stallBuffer(&((*m_reqRdy_ptr)), addr);
        (*m_reqRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallSnoop\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:331: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:332: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_snp = (true);
        stallBuffer(&((*m_snpRdy_ptr)), addr);
        (*m_snpRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallLocalEviction(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallLocalEviction\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:340: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_addr == addr))) {
    panic("Runtime Error at CHI-cache-actions.sm:341: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_tgr = (true);
(((*m_replTriggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallLocalEviction: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallSnoop_NoTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallSnoop_NoTBE\n");
    try {
               stallBuffer(&((*m_snpRdy_ptr)), addr);
        (*m_snpRdy_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallSnoop_NoTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::StallActionOnHazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing StallActionOnHazard\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:354: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard))) {
    panic("Runtime Error at CHI-cache-actions.sm:355: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_wakeup_pending_tgr = (true);
        stallBuffer(&((*m_triggerQueue_ptr)), addr);
        (*m_triggerQueue_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:StallActionOnHazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_Miss\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                }
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdToOwner));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpShared));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadShared_HitUpstream_NoOwner(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadShared_HitUpstream_NoOwner\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdToSharer));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadShared_HitUpstream_NoOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_Miss\n");
    try {
       (*m_tbe_ptr).m_dataToBeInvalid = ((*m_tbe_ptr).m_doCacheFill == (false));
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr == NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:426: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                        if ((*m_tbe_ptr).m_dataToBeInvalid) {
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadOnce));
                        } else {
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
                        }
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                    }
                }
                (*m_tbe_ptr).m_updateDirOnCompAck = (false);
                (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadOnce_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadOnce_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnceFwd));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
    }
    (*m_tbe_ptr).m_updateDirOnCompAck = (false);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadOnce_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Miss\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((m_is_HN && (*m_tbe_ptr).m_use_DMT)) {
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
            if (m_enable_DMT_early_dealloc) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendRespSepData));
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendReadNoSnpDMT));
        } else {
                if (m_is_HN) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadNoSnp));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
                }
            }
            (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
            (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_AutoUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_AutoUpgrade\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:503: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataUnique = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_AutoUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Upgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Upgrade\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:509: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_use_DCT == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:510: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:511: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:512: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if ((*m_tbe_ptr).m_dataMaybeDirtyUpstream) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
            } else {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataValid)) {
                    panic("Runtime Error at CHI-cache-actions.sm:521: %s.\n", "assert failure");

                }
                #endif
                ;
            }
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromRU));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Upgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Hit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_HitUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_HitUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
(*m_tbe_ptr).m_use_DCT = (((*m_tbe_ptr).m_use_DCT && ((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) && ((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false)));
    if ((*m_tbe_ptr).m_use_DCT) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueFwd));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
            if ((*m_tbe_ptr).m_dataMaybeDirtyUpstream) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
                (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
            }
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_HitUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_ReadUnique_Hit_InvUpstream(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_ReadUnique_Hit_InvUpstream\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadHitPipe));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompData));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_ReadUnique_Hit_InvUpstream: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CleanUnique\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_ReadMissPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCResp));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    } else {
            if (((((*m_tbe_ptr).m_dir_sharers).count()) > (1))) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalidNoReq));
            }
            (*m_tbe_ptr).m_dataUnique = ((*m_tbe_ptr).m_dataUnique || m_is_HN);
                if (((*m_tbe_ptr).m_dataUnique == (false))) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromCU));
                }
                (((*m_tbe_ptr).m_actions).push(Cache_Event_FinishCleanUnique));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finish_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finish_CleanUnique\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:604: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompUCResp));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WaitCompAck));
    if (((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false))) {
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:611: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
            panic("Runtime Error at CHI-cache-actions.sm:614: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataUnique)) {
            panic("Runtime Error at CHI-cache-actions.sm:615: %s.\n", "assert failure");

        }
        #endif
        ;
        bool fill_pipeline
         = ((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty);
        bool req_has_dirty
         = ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == (*m_tbe_ptr).m_requestor));
            if (((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) && (*m_tbe_ptr).m_dataToBeInvalid) && (req_has_dirty == (false)))) {
                fill_pipeline = (false);
                    if (m_is_HN) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
                    } else {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteClean));
                    }
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                }
                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (true);
                (*m_tbe_ptr).m_dir_ownerExists = (false);
                    if (fill_pipeline) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
                    }
                }
                (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finish_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_LoadHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_LoadHit\n");
    try {
           if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_LoadHit));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_LoadHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_LoadMiss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_LoadMiss\n");
    try {
           if ((*m_tbe_ptr).m_doCacheFill) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadShared));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadOnce));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_LoadMiss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreHit\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
(((*m_tbe_ptr).m_actions).push(Cache_Event_StoreHit));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
(((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreMiss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreMiss\n");
    try {
           if ((*m_tbe_ptr).m_doCacheFill) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteUnique));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUDataCB));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreMiss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_StoreUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_StoreUpgrade\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:687: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:688: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendCleanUnique));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckUpgrade_FromStore));
(((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
(((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_StoreUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_LocalWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_LocalWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN || (*m_tbe_ptr).m_dataUnique))) {
    panic("Runtime Error at CHI-cache-actions.sm:697: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataUnique = (true);
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
    }
        if (m_comp_wu) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_LocalWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_LocalWrite_AfterUpgrade(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_LocalWrite_AfterUpgrade\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:715: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:716: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendReadUnique));
    if (m_comp_wu) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_LocalWrite_AfterUpgrade: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_Writeback(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_Writeback\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:731: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:732: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
    if (m_comp_wu) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnp));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnp));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
    (*m_tbe_ptr).m_dataToBeInvalid = (true);
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_Writeback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_PartialWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_PartialWrite\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:751: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
    }
        if (m_comp_wu) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnpPartial));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
            (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteNoSnpPartial));
        }
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_PartialWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_WriteUnique_Forward(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_WriteUnique_Forward\n");
    try {
           if (m_comp_wu) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteUnique));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendComp_WU));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompDBIDResp_WU));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendWriteUnique));
    }
    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWUData));
    (*m_tbe_ptr).m_dataToBeInvalid = (true);
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_WriteUnique_Forward: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CopyBack(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CopyBack\n");
    try {
           if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteBackFull)) {
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UD_PD));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SD_PD));
    } else {
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_WriteEvictFull)) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_WriteEvictFull))) {
                    panic("Runtime Error at CHI-cache-actions.sm:797: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UC));
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SC));
            } else {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_WriteCleanFull))) {
                    panic("Runtime Error at CHI-cache-actions.sm:801: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_UD_PD));
                (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SD_PD));
            }
        }
        (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompDBIDResp));
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_MaintainCoherence));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CopyBack: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_CopyBack_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_CopyBack_Stale\n");
    try {
       (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_SC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CBWrData_I));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_SendCompDBIDRespStale));
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_WriteFEPipe));
    if (((((m_is_HN == (false)) && ((((*m_tbe_ptr).m_dir_sharers).count()) == (1))) && (((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor))) && ((*m_tbe_ptr).m_dataValid == (false)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
    }
    (((*m_tbe_ptr).m_dir_sharers).remove((*m_tbe_ptr).m_requestor));
    #ifndef NDEBUG
    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != (*m_tbe_ptr).m_requestor)))) {
        panic("Runtime Error at CHI-cache-actions.sm:829: %s.\n", "assert failure");

    }
    #endif
    ;
        if (((((m_cache_entry_ptr != NULL) && ((*m_tbe_ptr).m_dataValid == (false))) && (*m_tbe_ptr).m_dir_ownerExists) && (*m_tbe_ptr).m_dir_ownerIsExcl)) {
            (*m_tbe_ptr).m_dataValid = (true);
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_CopyBack_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Evict\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SendCompIResp));
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)))) {
    panic("Runtime Error at CHI-cache-actions.sm:843: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != (*m_tbe_ptr).m_requestor)))) {
    panic("Runtime Error at CHI-cache-actions.sm:844: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_dir_sharers).remove((*m_tbe_ptr).m_requestor));
    if ((((m_is_HN == (false)) && ((((*m_tbe_ptr).m_dir_sharers).count()) == (0))) && ((*m_tbe_ptr).m_dataValid == (false)))) {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
    }
    (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_MaitainCoherence(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_MaitainCoherence\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:858: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataToBeInvalid)) {
            if (m_is_HN) {
                    if (((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                    }
                } else {
                        if (((((*m_tbe_ptr).m_dir_sharers).isEmpty()) && ((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique))) {
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                        } else {
                                if (((((((*m_tbe_ptr).m_dir_sharers).isEmpty()) == (false)) && (*m_tbe_ptr).m_dataDirty) && ((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteClean));
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
                                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
                                }
                            }
                        }
                    } else {
                            if ((*m_tbe_ptr).m_dataValid) {
                                (((*m_tbe_ptr).m_actions).push(Cache_Event_CheckCacheFill));
                            }
                        }
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_MaitainCoherence: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_InvalidationSnoop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_InvalidationSnoop\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpInvPipe));
    if (((((*m_tbe_ptr).m_dir_sharers).count()) > (0))) {
            if ((((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd) || ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique))) {
                    if ((((*m_tbe_ptr).m_snpNeedsData && ((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false))) || ((*m_tbe_ptr).m_dataValid == (false)))) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueRetToSrc));
                    } else {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUnique));
                    }
                } else {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpCleanInvalid))) {
                        panic("Runtime Error at CHI-cache-actions.sm:903: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
                }
            }
                if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd)) {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpUniqueFwdCompData));
                } else {
                    (((*m_tbe_ptr).m_actions).push(Cache_Event_SendInvSnpResp));
                }
                    if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
                    } else {
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
                    }
                    (*m_tbe_ptr).m_dataToBeInvalid = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_InvalidationSnoop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_SnpShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_SnpShared\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpSharedPipe));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
            panic("Runtime Error at CHI-cache-actions.sm:927: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpShared));
    } else {
            if (((*m_tbe_ptr).m_dataValid == (false))) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:931: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:932: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
            } else {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
            }
        }
            if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpSharedFwd)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpSharedFwdCompData));
            } else {
                    if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpNotSharedDirtyFwd)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpNotSharedDirtyFwdCompData));
                    } else {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpShared))) {
                            panic("Runtime Error at CHI-cache-actions.sm:943: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpData));
                    }
                }
                    if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                        (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
                    } else {
                        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
                    }
                    (*m_tbe_ptr).m_dataToBeSharedClean = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_SnpShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_SnpOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_SnpOnce\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_SnpOncePipe));
    if (((*m_tbe_ptr).m_dataValid == (false))) {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-actions.sm:957: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnce));
    } else {
        (((*m_tbe_ptr).m_actions).push(Cache_Event_DataArrayRead));
    }
        if (((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnceFwd)) {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpOnceFwdCompData));
        } else {
            #ifndef NDEBUG
            if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnce))) {
                panic("Runtime Error at CHI-cache-actions.sm:966: %s.\n", "assert failure");

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!((*m_tbe_ptr).m_snpNeedsData)) {
                panic("Runtime Error at CHI-cache-actions.sm:967: %s.\n", "assert failure");

            }
            #endif
            ;
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpData));
        }
            if (((*m_tbe_ptr).m_is_req_hazard || (*m_tbe_ptr).m_is_repl_hazard)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_RestoreFromHazard));
            } else {
                (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_SnpOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_Evict_BackInvalidte(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_Evict_BackInvalidte\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:981: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_Evict_BackInvalidte: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_Evict\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:989: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:990: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendEvict));
(*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_JustDrop(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_JustDrop\n");
    try {
       (*m_tbe_ptr).m_dataToBeInvalid = (true);
(((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_JustDrop: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_WB_BackInvalidate(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_WB_BackInvalidate\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) || (*m_tbe_ptr).m_dataMaybeDirtyUpstream))) {
    panic("Runtime Error at CHI-cache-actions.sm:1002: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_actions).push(Cache_Event_SendSnpCleanInvalid));
(((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
    if (m_is_HN) {
            if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
            }
        } else {
            (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_WB_BackInvalidate: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Initiate_Replacement_WB(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Initiate_Replacement_WB\n");
    try {
       (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteFEPipe));
    if (m_is_HN) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataDirty)) {
            panic("Runtime Error at CHI-cache-actions.sm:1023: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteNoSnp));
    } else {
            if ((((*m_tbe_ptr).m_dir_sharers).isEmpty())) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1026: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteBackOrWriteEvict));
            } else {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataDirty)) {
                    panic("Runtime Error at CHI-cache-actions.sm:1029: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWriteClean));
            }
        }
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_DataArrayRead));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_WriteBEPipe));
        (((*m_tbe_ptr).m_actions).push(Cache_Event_SendWBData));
        (*m_tbe_ptr).m_dataToBeInvalid = (true);
        (((*m_tbe_ptr).m_actions).pushNB(Cache_Event_TagArrayWrite));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Initiate_Replacement_WB: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadShared\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1042: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1043: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_SC));
    if (m_allow_SD) {
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_SD_PD));
    }
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
    (((*m_tbe_ptr).m_dataBlkValid).clear());
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            if (m_allow_SD) {
                (prepareRequest(m_tbe_ptr, CHIRequestType_ReadShared, *out_msg));
            } else {
                (prepareRequest(m_tbe_ptr, CHIRequestType_ReadNotSharedDirty, *out_msg));
            }
            (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
            (*out_msg).m_dataToFwdRequestor = (false);
            (allowRequestRetry(m_tbe_ptr, *out_msg));
            ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadNoSnp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadNoSnp\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1071: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_use_DMT == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1072: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
(((*m_tbe_ptr).m_dataBlkValid).clear());
(outgoingTransactionStart(addr, (curTransitionEvent())));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadNoSnp, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadNoSnp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadNoSnpDMT(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadNoSnpDMT\n");
    try {
       #ifndef NDEBUG
if (!(m_is_HN)) {
    panic("Runtime Error at CHI-cache-actions.sm:1091: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_use_DMT)) {
    panic("Runtime Error at CHI-cache-actions.sm:1092: %s.\n", "assert failure");

}
#endif
;
CHIRequestType req
 = CHIRequestType_ReadNoSnp;
    if (m_enable_DMT_early_dealloc) {
        req = CHIRequestType_ReadNoSnpSep;
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_ReadReceipt));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
    }
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, req, *out_msg));
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (*out_msg).m_dataToFwdRequestor = (true);
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadNoSnpDMT: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadOnce\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1110: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1111: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_I));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
(((*m_tbe_ptr).m_dataBlkValid).clear());
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadOnce, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_ReadUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_ReadUnique\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataUnique) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1131: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1133: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_DataSepResp_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UC));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_CompData_UD_PD));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_RespSepData));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((2)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_ReadUnique, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (*out_msg).m_dataToFwdRequestor = (false);
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_ReadUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CleanUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CleanUnique\n");
    try {
       #ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid || ((((*m_tbe_ptr).m_dir_sharers).count()) > (0))))) {
    panic("Runtime Error at CHI-cache-actions.sm:1151: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1152: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1154: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_UC));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_CleanUnique, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CleanUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Evict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Evict\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1167: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1168: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_req_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1169: %s.\n", "assert failure");

}
#endif
;
(clearExpectedReqResp(m_tbe_ptr));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_Evict, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp_I));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Evict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_InvSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_InvSnpResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1181: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1182: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_snpNeedsData) || ((*m_tbe_ptr).m_dataUnique && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique)))) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpData));
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpIResp));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_InvSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteBackOrWriteEvict(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteBackOrWriteEvict\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1192: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1193: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:1194: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1195: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique || (*m_tbe_ptr).m_dataDirty))) {
    panic("Runtime Error at CHI-cache-actions.sm:1197: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dir_sharers).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1198: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        if ((*m_tbe_ptr).m_dataDirty) {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteBackFull, *out_msg));
        } else {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteEvictFull, *out_msg));
        }
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
    }
    (clearExpectedReqResp(m_tbe_ptr));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteBackOrWriteEvict: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteCleanFull(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteCleanFull\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1215: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1216: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:1217: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1218: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataDirty)) {
    panic("Runtime Error at CHI-cache-actions.sm:1219: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1220: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteCleanFull, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(clearExpectedReqResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteCleanFull: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteNoSnp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteNoSnp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1233: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteNoSnp, *out_msg));
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteNoSnp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteNoSnp_Partial(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteNoSnp_Partial\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1247: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_WriteNoSnpPtl, *out_msg));
    (*out_msg).m_accAddr = (*m_tbe_ptr).m_accAddr;
    (*out_msg).m_accSize = (*m_tbe_ptr).m_accSize;
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    (allowRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteNoSnp_Partial: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WriteUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WriteUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1263: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        if (((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr))) {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteUniqueFull, *out_msg));
        } else {
            (prepareRequest(m_tbe_ptr, CHIRequestType_WriteUniquePtl, *out_msg));
            (*out_msg).m_accAddr = (*m_tbe_ptr).m_accAddr;
            (*out_msg).m_accSize = (*m_tbe_ptr).m_accSize;
        }
        (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
        (allowRequestRetry(m_tbe_ptr, *out_msg));
        ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
    }
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompDBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_DBIDResp));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WriteUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpCleanInvalid(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpCleanInvalid\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1285: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1286: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1288: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpCleanInvalid, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}
(setExpectedForInvSnoop(m_tbe_ptr, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpCleanInvalid: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpCleanInvalid_NoReq(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpCleanInvalid_NoReq\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1298: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1299: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpCleanInvalid, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (((*out_msg).m_Destination).remove((*m_tbe_ptr).m_requestor));
    #ifndef NDEBUG
    if (!(((((*out_msg).m_Destination).count()) > (0)))) {
        panic("Runtime Error at CHI-cache-actions.sm:1305: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_retToSrc = (false);
    (setExpectedForInvSnoop(m_tbe_ptr, (false)));
    (((*m_tbe_ptr).m_expected_snp_resp).setExpectedCount((((*out_msg).m_Destination).count())));
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpCleanInvalid_NoReq: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1313: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1315: %s.\n", "assert failure");

}
#endif
;
(setExpectedForInvSnoop(m_tbe_ptr, (true)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUnique_RetToSrc(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUnique_RetToSrc\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1327: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1329: %s.\n", "assert failure");

}
#endif
;
(setExpectedForInvSnoop(m_tbe_ptr, (true)));
MachineID dest;
    if ((*m_tbe_ptr).m_dir_ownerExists) {
        dest = (*m_tbe_ptr).m_dir_owner;
    } else {
        dest = (((*m_tbe_ptr).m_dir_sharers).smallestElement());
    }
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
        (((*out_msg).m_Destination).add(dest));
        (*out_msg).m_retToSrc = (true);
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
    }
        if (((((*m_tbe_ptr).m_dir_sharers).count()) > (1))) {
            {
                std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
                (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUnique, *out_msg));
                (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
                (((*out_msg).m_Destination).remove(dest));
                (*out_msg).m_retToSrc = (false);
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUnique_RetToSrc: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpUniqueFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpUniqueFwd\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1357: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1359: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1361: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I_Fwded_UC));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I_Fwded_UD_PD));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpUniqueFwd, *out_msg));
    (((*out_msg).m_Destination).addNetDest((*m_tbe_ptr).m_dir_sharers));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpUniqueFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpShared(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpShared\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1375: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
    panic("Runtime Error at CHI-cache-actions.sm:1378: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dir_ownerExists)) {
    panic("Runtime Error at CHI-cache-actions.sm:1379: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1380: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1382: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC));
(((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_PD));
(((*m_tbe_ptr).m_expected_snp_resp).setExpectedCount((1)));
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequest(m_tbe_ptr, CHIRequestType_SnpShared, *out_msg));
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
    (*out_msg).m_retToSrc = (false);
    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpShared: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpSharedFwd_ToOwner(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpSharedFwd_ToOwner\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1396: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
    panic("Runtime Error at CHI-cache-actions.sm:1399: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dir_ownerExists)) {
    panic("Runtime Error at CHI-cache-actions.sm:1400: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1401: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1403: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
bool allowFwdSD
 = ((*m_tbe_ptr).m_reqType != CHIRequestType_ReadNotSharedDirty);
bool retToSrc
 = ((*m_tbe_ptr).m_doCacheFill && ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
    if (allowFwdSD) {
            if (retToSrc) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SD_PD));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SD_PD));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SD_PD));
            }
        } else {
                if (retToSrc) {
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_Fwded_SC));
                } else {
                    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
                }
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_PD_Fwded_SC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_PD_Fwded_SC));
            }
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
            {
                std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
                    if (allowFwdSD) {
                        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpSharedFwd, *out_msg));
                    } else {
                        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpNotSharedDirtyFwd, *out_msg));
                    }
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                    (*out_msg).m_retToSrc = retToSrc;
                    ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
                }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpSharedFwd_ToOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpSharedFwd_ToSharer(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpSharedFwd_ToSharer\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1445: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1447: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1448: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1449: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1451: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
bool retToSrc
 = (*m_tbe_ptr).m_doCacheFill;
    if (retToSrc) {
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC_Fwded_SC));
    } else {
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_SC));
    }
    (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
    {
        std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
        (prepareRequest(m_tbe_ptr, CHIRequestType_SnpSharedFwd, *out_msg));
        (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
        (*out_msg).m_retToSrc = retToSrc;
        ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpSharedFwd_ToSharer: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpOnce(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpOnce\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1472: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1475: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1477: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
            if ((*m_tbe_ptr).m_dir_ownerIsExcl) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_UC));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_UD));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SD));
            }
        } else {
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_SC));
        }
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            (prepareRequest(m_tbe_ptr, CHIRequestType_SnpOnce, *out_msg));
                if ((*m_tbe_ptr).m_dir_ownerExists) {
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                } else {
                    (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
                }
                (*out_msg).m_retToSrc = (true);
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpOnce: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpOnceFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpOnceFwd\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1505: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1508: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_expected_snp_resp).expected()) == (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1510: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(m_tbe_ptr));
    if ((*m_tbe_ptr).m_dir_ownerExists) {
            if ((*m_tbe_ptr).m_dir_ownerIsExcl) {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_UC_Fwded_I));
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_UD_Fwded_I));
            } else {
                (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SD_Fwded_I));
            }
        } else {
            (((*m_tbe_ptr).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_SC_Fwded_I));
        }
        (((*m_tbe_ptr).m_expected_snp_resp).addExpectedCount((1)));
        {
            std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
            (prepareRequest(m_tbe_ptr, CHIRequestType_SnpOnceFwd, *out_msg));
                if ((*m_tbe_ptr).m_dir_ownerExists) {
                    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_dir_owner));
                } else {
                    (((*out_msg).m_Destination).add((((*m_tbe_ptr).m_dir_sharers).smallestElement())));
                }
                (*out_msg).m_retToSrc = (false);
                ((*m_snpOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_snoop_latency)));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpOnceFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectNCBWrData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectNCBWrData\n");
    try {
       int num_msgs
 = ((*m_tbe_ptr).m_accSize / m_data_channel_size);
    if ((((*m_tbe_ptr).m_accSize % m_data_channel_size) != (0))) {
        num_msgs = (num_msgs + (1));
    }
    (((*m_tbe_ptr).m_expected_req_resp).clear(num_msgs));
    (((*m_tbe_ptr).m_expected_req_resp).addExpectedDataType(CHIDataType_NCBWrData));
    (((*m_tbe_ptr).m_expected_req_resp).setExpectedCount((1)));
    (((*m_tbe_ptr).m_dataBlkValid).setMask((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)), (*m_tbe_ptr).m_accSize, (false)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectNCBWrData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ExpectCompAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ExpectCompAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1553: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_CompAck));
(((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ExpectCompAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1559: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1560: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveData(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1564: %s.\n", ("Received unexpected message"));
        ;
    }
        if ((((((((((*m_tbe_ptr).m_dataBlkValid).isFull()) == (false)) || (((*in_msg_ptr)).m_type == CHIDataType_CompData_UD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CompData_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_NCBWrData))) {
                if ((((*m_tbe_ptr).m_dataBlkValid).isFull())) {
                    (((*m_tbe_ptr).m_dataBlkValid).clear());
                }
                (((*m_tbe_ptr).m_dataBlk).copyPartial(((*in_msg_ptr)).m_dataBlk, ((*in_msg_ptr)).m_bitMask));
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dataBlkValid).isOverlap(((*in_msg_ptr)).m_bitMask)) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1579: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_dataBlkValid).orMask(((*in_msg_ptr)).m_bitMask));
            }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RespSepDataFromCompData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RespSepDataFromCompData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1586: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1587: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receivedRespType(CHIResponseType_RespSepData)) == (false))) {
            if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_RespSepData)) == (false))) {
                panic("Runtime Error at CHI-cache-actions.sm:1591: %s.\n", ("Received unexpected message"));
                ;
            }
                if ((m_is_HN == (false))) {
                    (((*m_tbe_ptr).m_actions).pushFrontNB(Cache_Event_SendCompAck));
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RespSepDataFromCompData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RespSepData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RespSepData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1601: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1602: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_RespSepData)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1604: %s.\n", ("Received unexpected message"));
        ;
    }
        if ((m_is_HN == (false))) {
            (((*m_tbe_ptr).m_actions).pushFrontNB(Cache_Event_SendCompAck));
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RespSepData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReadReceipt(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReadReceipt\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1613: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1614: %s.\n", "assert failure");

}
#endif
;
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_ReadReceipt)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1616: %s.\n", ("Received unexpected message"));
        ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReadReceipt: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_SnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_SnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1621: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:1622: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_snp_resp).receiveData(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:1626: %s.\n", ("Received unexpected message"));
        ;
    }
        if (((((((((((*m_tbe_ptr).m_dataBlkValid).isFull()) == (false)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC))) {
                if ((((*m_tbe_ptr).m_dataBlkValid).isFull())) {
                    (((*m_tbe_ptr).m_dataBlkValid).clear());
                }
                (((*m_tbe_ptr).m_dataBlk).copyPartial(((*in_msg_ptr)).m_dataBlk, ((*in_msg_ptr)).m_bitMask));
                #ifndef NDEBUG
                if (!(((((*m_tbe_ptr).m_dataBlkValid).isOverlap(((*in_msg_ptr)).m_bitMask)) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1642: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_dataBlkValid).orMask(((*in_msg_ptr)).m_bitMask));
            }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_SnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1649: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1652: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UC)) {
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1656: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1657: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_ownerExists = (false);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) {
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_ownerExists && (*m_tbe_ptr).m_dir_ownerIsExcl) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1663: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1664: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_pendReqType != CHIRequestType_WriteCleanFull)) {
                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                            }
                        } else {
                                if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SC)) {
                                    #ifndef NDEBUG
                                    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:1672: %s.\n", "assert failure");

                                    }
                                    #endif
                                    ;
                                    (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                } else {
                                        if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) {
                                            #ifndef NDEBUG
                                            if (!((((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_ownerIsExcl == (false))) && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                panic("Runtime Error at CHI-cache-actions.sm:1676: %s.\n", "assert failure");

                                            }
                                            #endif
                                            ;
                                            #ifndef NDEBUG
                                            if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                panic("Runtime Error at CHI-cache-actions.sm:1677: %s.\n", "assert failure");

                                            }
                                            #endif
                                            ;
                                            (*m_tbe_ptr).m_dir_ownerExists = (false);
                                            (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                                if (((*m_tbe_ptr).m_pendReqType != CHIRequestType_WriteCleanFull)) {
                                                    (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                                }
                                            } else {
                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_I)) {
                                                        #ifndef NDEBUG
                                                        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1686: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                        #ifndef NDEBUG
                                                        if (!(((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)) == (false)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1687: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                    } else {
                                                        panic("Runtime Error at CHI-cache-actions.sm:1690: %s.\n", ("Unsuported data type"));
                                                        ;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    }
                                }
                                (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromSnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromSnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1698: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_snp_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1701: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I)) {
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1705: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_ownerExists = (false);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD)) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1711: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1712: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dir_ownerExists = (false);
                        (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                    } else {
                            if ((((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC))) {
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1724: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1725: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                    if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD))) {
                                        (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                    }
                                        if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) {
                                            (*m_tbe_ptr).m_dir_ownerExists = (true);
                                            (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                        }
                                    } else {
                                            if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SC))) {
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1743: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1744: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                (*m_tbe_ptr).m_dir_ownerExists = (false);
                                                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                                                (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                                (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) {
                                                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                                                        (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                                    }
                                                } else {
                                                        if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD))) {
                                                            #ifndef NDEBUG
                                                            if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:1759: %s.\n", "assert failure");

                                                            }
                                                            #endif
                                                            ;
                                                            #ifndef NDEBUG
                                                            if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                                panic("Runtime Error at CHI-cache-actions.sm:1760: %s.\n", "assert failure");

                                                            }
                                                            #endif
                                                            ;
                                                        } else {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1763: %s.\n", ("Unsuported data type"));
                                                            ;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        }
                                    }
                                    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromSnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromReqDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromReqDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1771: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1774: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if (((((*in_msg_ptr)).m_type == CHIDataType_CompData_UC) || (((*in_msg_ptr)).m_type == CHIDataType_DataSepResp_UC))) {
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1779: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1780: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dataDirty = (false);
                (*m_tbe_ptr).m_dataUnique = (true);
                (*m_tbe_ptr).m_dataValid = (true);
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1784: %s.\n", "assert failure");

                }
                #endif
                ;
            } else {
                    if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_UD_PD)) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1787: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1788: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dataDirty = (true);
                        (*m_tbe_ptr).m_dataUnique = (true);
                        (*m_tbe_ptr).m_dataValid = (true);
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1792: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                    } else {
                            if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_SC)) {
                                #ifndef NDEBUG
                                if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1795: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                #ifndef NDEBUG
                                if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1796: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                (*m_tbe_ptr).m_dataDirty = (false);
                                (*m_tbe_ptr).m_dataUnique = (false);
                                (*m_tbe_ptr).m_dataValid = (true);
                                #ifndef NDEBUG
                                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                    panic("Runtime Error at CHI-cache-actions.sm:1800: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                            } else {
                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_SD_PD)) {
                                        #ifndef NDEBUG
                                        if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1803: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!((((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_dataDirty) == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1804: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        (*m_tbe_ptr).m_dataDirty = (true);
                                        (*m_tbe_ptr).m_dataUnique = (false);
                                        (*m_tbe_ptr).m_dataValid = (true);
                                        #ifndef NDEBUG
                                        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1808: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                    } else {
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CompData_I)) {
                                                (*m_tbe_ptr).m_dataValid = (true);
                                                (*m_tbe_ptr).m_dataToBeInvalid = (true);
                                                #ifndef NDEBUG
                                                if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1813: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                            } else {
                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UC)) {
                                                        #ifndef NDEBUG
                                                        if (!((*m_tbe_ptr).m_dataUnique)) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1816: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                        (*m_tbe_ptr).m_dataValid = (true);
                                                    } else {
                                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SC)) {
                                                            } else {
                                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_UD_PD)) {
                                                                        #ifndef NDEBUG
                                                                        if (!((*m_tbe_ptr).m_dataUnique)) {
                                                                            panic("Runtime Error at CHI-cache-actions.sm:1824: %s.\n", "assert failure");

                                                                        }
                                                                        #endif
                                                                        ;
                                                                        (*m_tbe_ptr).m_dataDirty = (true);
                                                                        (*m_tbe_ptr).m_dataValid = (true);
                                                                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                                    } else {
                                                                            if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_SD_PD)) {
                                                                                (*m_tbe_ptr).m_dataDirty = (true);
                                                                                (*m_tbe_ptr).m_dataValid = (true);
                                                                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                                                                            } else {
                                                                                    if ((((*in_msg_ptr)).m_type == CHIDataType_CBWrData_I)) {
                                                                                    } else {
                                                                                        panic("Runtime Error at CHI-cache-actions.sm:1838: %s.\n", ("Unsuported data type"));
                                                                                        ;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                }
                                            }
                                            (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromReqDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromWUDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromWUDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1846: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).test((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)))))) {
            panic("Runtime Error at CHI-cache-actions.sm:1848: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).test((((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)) + (*m_tbe_ptr).m_accSize) - (1)))))) {
            panic("Runtime Error at CHI-cache-actions.sm:1850: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!((((*in_msg_ptr)).m_type == CHIDataType_NCBWrData))) {
            panic("Runtime Error at CHI-cache-actions.sm:1852: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_dataDirty = (true);
        (*m_tbe_ptr).m_dataValid = ((*m_tbe_ptr).m_accSize == (*m_blockSize_ptr));
        }
    }
    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromWUDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromCUResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromCUResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1861: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    GEM5_VAR_USED const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_type == CHIResponseType_Comp_UC))) {
    panic("Runtime Error at CHI-cache-actions.sm:1863: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataUnique == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:1864: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_dataUnique = ((*m_tbe_ptr).m_dataValid || ((((*m_tbe_ptr).m_dir_sharers).count()) > (0)));
}
(printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromCUResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDataState_FromSnpDataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDataState_FromSnpDataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:1873: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_snp_resp).hasReceivedData())) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:1876: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_PD_Fwded_SC))) {
                (*m_tbe_ptr).m_dataDirty = (true);
                (*m_tbe_ptr).m_dataValid = (true);
                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
            } else {
                    if ((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SD) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SD_PD))) {
                        (*m_tbe_ptr).m_dataDirty = (true);
                        (*m_tbe_ptr).m_dataValid = (true);
                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                    } else {
                            if (((((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_SC_Fwded_SC)) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_I_Fwded_SC))) {
                                (*m_tbe_ptr).m_dataValid = (true);
                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (false);
                            } else {
                                    if (((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UC) || (((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD))) {
                                        (*m_tbe_ptr).m_dataValid = (true);
                                        (*m_tbe_ptr).m_dataUnique = (true);
                                        (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (true);
                                            if ((((*in_msg_ptr)).m_type == CHIDataType_SnpRespData_UD)) {
                                                (*m_tbe_ptr).m_dataDirty = (true);
                                            }
                                        } else {
                                            panic("Runtime Error at CHI-cache-actions.sm:1911: %s.\n", ("Unsuported data type"));
                                            ;
                                        }
                                    }
                                }
                            }
                            }
                        }
                        (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDataState_FromSnpDataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromReqResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromReqResp\n");
    try {
       {
    // Declare message
    GEM5_VAR_USED const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*in_msg_ptr)).m_type == CHIResponseType_CompAck) && (*m_tbe_ptr).m_updateDirOnCompAck)) {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_requestor == ((*in_msg_ptr)).m_responder))) {
            panic("Runtime Error at CHI-cache-actions.sm:1921: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_dir_sharers).add(((*in_msg_ptr)).m_responder));
            if ((*m_tbe_ptr).m_requestorToBeOwner) {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                    panic("Runtime Error at CHI-cache-actions.sm:1926: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1927: %s.\n", "assert failure");

                }
                #endif
                ;
                #ifndef NDEBUG
                if (!(((*m_tbe_ptr).m_requestorToBeExclusiveOwner == (false)))) {
                    panic("Runtime Error at CHI-cache-actions.sm:1928: %s.\n", "assert failure");

                }
                #endif
                ;
                (*m_tbe_ptr).m_dir_owner = ((*in_msg_ptr)).m_responder;
                (*m_tbe_ptr).m_dir_ownerExists = (true);
                (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
            } else {
                    if ((*m_tbe_ptr).m_requestorToBeExclusiveOwner) {
                        #ifndef NDEBUG
                        if (!((*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                            panic("Runtime Error at CHI-cache-actions.sm:1934: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_dir_ownerExists == (false)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1935: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
                            panic("Runtime Error at CHI-cache-actions.sm:1936: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        (*m_tbe_ptr).m_dir_owner = ((*in_msg_ptr)).m_responder;
                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                        (*m_tbe_ptr).m_dir_ownerIsExcl = (true);
                    }
                }
            }
            }
            (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromReqResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::UpdateDirState_FromSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing UpdateDirState_FromSnpResp\n");
    try {
       {
    // Declare message
    GEM5_VAR_USED const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I)) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
            panic("Runtime Error at CHI-cache-actions.sm:1951: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
            if (((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))) {
                (*m_tbe_ptr).m_dir_ownerExists = (false);
            }
        } else {
                if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC)) {
                    #ifndef NDEBUG
                    if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:1959: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                    #ifndef NDEBUG
                    if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:1960: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                } else {
                        if (((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SC) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD))) {
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder))))) {
                                panic("Runtime Error at CHI-cache-actions.sm:1966: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                panic("Runtime Error at CHI-cache-actions.sm:1967: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                            (*m_tbe_ptr).m_dir_ownerExists = (false);
                            (*m_tbe_ptr).m_dir_ownerIsExcl = (false);
                            (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD)) {
                                    (*m_tbe_ptr).m_dir_ownerExists = (true);
                                    (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                }
                            } else {
                                    if (((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I_Fwded_UC) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_I_Fwded_UD_PD))) {
                                        #ifndef NDEBUG
                                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1980: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) == (1)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:1981: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        (((*m_tbe_ptr).m_dir_sharers).remove(((*in_msg_ptr)).m_responder));
                                        (((*m_tbe_ptr).m_dir_sharers).add((*m_tbe_ptr).m_requestor));
                                        (*m_tbe_ptr).m_dir_ownerExists = (true);
                                        (*m_tbe_ptr).m_dir_ownerIsExcl = (true);
                                        (*m_tbe_ptr).m_dir_owner = (*m_tbe_ptr).m_requestor;
                                    } else {
                                            if ((((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_UC_Fwded_I) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_UD_Fwded_I)) || (((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SD_Fwded_I))) {
                                                #ifndef NDEBUG
                                                if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1993: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!(((*m_tbe_ptr).m_dir_ownerExists && ((*m_tbe_ptr).m_dir_owner == ((*in_msg_ptr)).m_responder)))) {
                                                    panic("Runtime Error at CHI-cache-actions.sm:1994: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                            } else {
                                                    if ((((*in_msg_ptr)).m_type == CHIResponseType_SnpResp_SC_Fwded_I)) {
                                                        #ifndef NDEBUG
                                                        if (!((((*m_tbe_ptr).m_dir_sharers).isElement(((*in_msg_ptr)).m_responder)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1998: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                        #ifndef NDEBUG
                                                        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) || ((*m_tbe_ptr).m_dir_owner != ((*in_msg_ptr)).m_responder)))) {
                                                            panic("Runtime Error at CHI-cache-actions.sm:1999: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                (*m_tbe_ptr).m_dataMaybeDirtyUpstream = (*m_tbe_ptr).m_dir_ownerExists;
                                }
                                (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:UpdateDirState_FromSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_req_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2009: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    GEM5_VAR_USED const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2013: %s.\n", ("Received unexpected message"));
        ;
    }
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_stale == (*m_tbe_ptr).m_is_stale))) {
        panic("Runtime Error at CHI-cache-actions.sm:2015: %s.\n", "assert failure");

    }
    #endif
    ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp_WUNeedComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp_WUNeedComp\n");
    try {
       (*m_tbe_ptr).m_defer_expected_comp = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp_WUNeedComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_ReqResp_WUComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_ReqResp_WUComp\n");
    try {
           if ((*m_tbe_ptr).m_defer_expected_comp) {
        (*m_tbe_ptr).m_defer_expected_comp = (false);
    } else {
            if (((((*m_tbe_ptr).m_expected_req_resp).receiveResp(CHIResponseType_Comp)) == (false))) {
                panic("Runtime Error at CHI-cache-actions.sm:2027: %s.\n", ("Received unexpected message"));
                ;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_ReqResp_WUComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_SnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_SnpResp\n");
    try {
       #ifndef NDEBUG
if (!((((*m_tbe_ptr).m_expected_snp_resp).hasExpected()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2032: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    GEM5_VAR_USED const CHIResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (((((*m_tbe_ptr).m_expected_snp_resp).receiveResp(((*in_msg_ptr)).m_type)) == (false))) {
        panic("Runtime Error at CHI-cache-actions.sm:2036: %s.\n", ("Received unexpected message"));
        ;
    }
    #ifndef NDEBUG
    if (!((((*in_msg_ptr)).m_stale == (*m_tbe_ptr).m_is_stale))) {
        panic("Runtime Error at CHI-cache-actions.sm:2038: %s.\n", "assert failure");

    }
    #endif
    ;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_SnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RetryAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RetryAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2043: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2044: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_rcvdRetryAck == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2045: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_rcvdRetryAck = (true);
(((*m_destsWaitingRetry_ptr)).addNetDest((*m_tbe_ptr).m_pendReqDest));
(enqueueDoRetry(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RetryAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_PCrdGrant(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_PCrdGrant\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2052: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_rcvdRetryCredit == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2053: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_rcvdRetryCredit = (true);
(enqueueDoRetry(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_PCrdGrant: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2059: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2060: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2061: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequestRetry(m_tbe_ptr, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_RetryAck_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_RetryAck_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2069: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*hazard_tbe).m_rcvdRetryAck == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2070: %s.\n", "assert failure");

}
#endif
;
(*hazard_tbe).m_rcvdRetryAck = (true);
(((*m_destsWaitingRetry_ptr)).addNetDest((*hazard_tbe).m_pendReqDest));
(enqueueDoRetry(hazard_tbe));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_RetryAck_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Receive_PCrdGrant_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Receive_PCrdGrant_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2078: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*hazard_tbe).m_rcvdRetryCredit == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2079: %s.\n", "assert failure");

}
#endif
;
(*hazard_tbe).m_rcvdRetryCredit = (true);
(enqueueDoRetry(hazard_tbe));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Receive_PCrdGrant_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Retry_Hazard(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Retry_Hazard\n");
    try {
       Cache_TBE* hazard_tbe
 = (getHazardTBE(m_tbe_ptr));
#ifndef NDEBUG
if (!((*hazard_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-actions.sm:2086: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*hazard_tbe).m_rcvdRetryCredit)) {
    panic("Runtime Error at CHI-cache-actions.sm:2087: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*hazard_tbe).m_rcvdRetryAck)) {
    panic("Runtime Error at CHI-cache-actions.sm:2088: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(clockEdge());
    (prepareRequestRetry(hazard_tbe, *out_msg));
    ((*m_reqOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_request_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Retry_Hazard: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2095: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2096: %s.\n", "assert failure");

}
#endif
;
bool is_rd_once
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadOnce);
bool is_rd_shared
 = (((*m_tbe_ptr).m_reqType == CHIRequestType_ReadShared) || ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadNotSharedDirty));
bool is_rd_nsd
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadNotSharedDirty);
bool is_rd_unique
 = ((*m_tbe_ptr).m_reqType == CHIRequestType_ReadUnique);
    if (is_rd_once) {
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_I;
    } else {
            if ((*m_tbe_ptr).m_dataToBeInvalid) {
                    if (((*m_tbe_ptr).m_dataUnique && (*m_tbe_ptr).m_dataDirty)) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UD_PD;
                    } else {
                            if ((*m_tbe_ptr).m_dataUnique) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UC;
                            } else {
                                    if ((*m_tbe_ptr).m_dataDirty) {
                                            if (is_rd_nsd) {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
                                            } else {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SD_PD;
                                            }
                                        } else {
                                            (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
                                        }
                                    }
                                }
                            } else {
                                    if ((is_rd_unique || (((is_rd_shared && (*m_tbe_ptr).m_dataUnique) && m_fwd_unique_on_readshared) && ((*m_tbe_ptr).m_dir_ownerExists == (false))))) {
                                        #ifndef NDEBUG
                                        if (!((*m_tbe_ptr).m_dataUnique)) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2125: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                            if ((*m_tbe_ptr).m_dataDirty) {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UD_PD;
                                            } else {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UC;
                                            }
                                        } else {
                                                if (is_rd_shared) {
                                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
                                                } else {
                                                    panic("Runtime Error at CHI-cache-actions.sm:2135: %s.\n", ("Invalid request type"));
                                                    ;
                                                }
                                            }
                                        }
                                    }
                                    (*m_tbe_ptr).m_dataMaybeDirtyUpstream = ((((*m_tbe_ptr).m_dataMaybeDirtyUpstream || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_SD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UC));
                                    (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (((*m_tbe_ptr).m_requestorToBeExclusiveOwner || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UD_PD)) || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_UC));
                                    (*m_tbe_ptr).m_requestorToBeOwner = ((*m_tbe_ptr).m_requestorToBeOwner || ((*m_tbe_ptr).m_snd_msgType == CHIDataType_CompData_SD_PD));
                                    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                                    (setupPendingSend(m_tbe_ptr));
                                    (printTBEState(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WBData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WBData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2154: %s.\n", "assert failure");

}
#endif
;
    if (m_is_HN) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2156: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataDirty)) {
            panic("Runtime Error at CHI-cache-actions.sm:2157: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2158: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
    } else {
            if (((*m_tbe_ptr).m_dataValid == (false))) {
                #ifndef NDEBUG
                if (!((*m_tbe_ptr).m_is_stale)) {
                    panic("Runtime Error at CHI-cache-actions.sm:2163: %s.\n", "assert failure");

                }
                #endif
                ;
                (((*m_tbe_ptr).m_dataBlkValid).fillMask());
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_I;
            } else {
                    if ((*m_tbe_ptr).m_dataUnique) {
                        #ifndef NDEBUG
                        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2167: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if ((*m_tbe_ptr).m_dataDirty) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_UD_PD;
                            } else {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_UC;
                            }
                        } else {
                            #ifndef NDEBUG
                            if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
                                panic("Runtime Error at CHI-cache-actions.sm:2174: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                                if ((*m_tbe_ptr).m_dataDirty) {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_SD_PD;
                                } else {
                                    (*m_tbe_ptr).m_snd_msgType = CHIDataType_CBWrData_SC;
                                }
                            }
                        }
                    }
                    (*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
                    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WBData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_WUData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_WUData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2187: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_dataBlkValid).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2188: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_NCBWrData;
(*m_tbe_ptr).m_snd_destination = (mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr));
(setupPendingPartialSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_WUData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckWUComp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckWUComp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2195: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_defer_expected_comp) {
        (*m_tbe_ptr).m_defer_expected_comp = (false);
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedCount((1)));
        (((*m_tbe_ptr).m_expected_req_resp).addExpectedRespType(CHIResponseType_Comp));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckWUComp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespData\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2204: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2205: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2206: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2207: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_snpNeedsData || ((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpCleanInvalid))) || (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpShared))) || (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataUnique) && ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUnique))))) {
    panic("Runtime Error at CHI-cache-actions.sm:2212: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataToBeInvalid) {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2215: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((*m_tbe_ptr).m_dataDirty) {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_PD;
            } else {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I;
            }
        } else {
                if ((*m_tbe_ptr).m_dataToBeSharedClean) {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2222: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                        if ((*m_tbe_ptr).m_dataDirty) {
                            (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_PD;
                        } else {
                            (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC;
                        }
                    } else {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnce))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2229: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_dataDirty && (*m_tbe_ptr).m_dataUnique)) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_UD;
                            } else {
                                    if ((*m_tbe_ptr).m_dataDirty) {
                                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SD;
                                    } else {
                                            if ((*m_tbe_ptr).m_dataUnique) {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_UC;
                                            } else {
                                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC;
                                            }
                                        }
                                    }
                                }
                            }
                            (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                            (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpUniqueFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpUniqueFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2246: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeInvalid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2247: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2248: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataDirty) {
        (*m_tbe_ptr).m_fwdedState = Cache_State_UD;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UD_PD;
    } else {
        (*m_tbe_ptr).m_fwdedState = Cache_State_UC;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_UC;
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpUniqueFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpSharedFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpSharedFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2264: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:2265: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2266: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataDirty) {
        (*m_tbe_ptr).m_fwdedState = Cache_State_SD;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SD_PD;
    } else {
        (*m_tbe_ptr).m_fwdedState = Cache_State_SC;
        (*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
    }
        if ((*m_tbe_ptr).m_snpNeedsData) {
            (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedData));
        } else {
            (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
        }
        (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
        (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpSharedFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpNSDFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpNSDFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2286: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:2287: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2288: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_SC;
(*m_tbe_ptr).m_fwdedState = Cache_State_SC;
    if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_snpNeedsData)) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedData));
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
    }
    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpNSDFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompData_SnpOnceFwd(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompData_SnpOnceFwd\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2303: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_fwdedState = Cache_State_I;
(*m_tbe_ptr).m_snd_msgType = CHIDataType_CompData_I;
(((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendSnpFwdedResp));
(*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_fwdRequestor;
(setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompData_SnpOnceFwd: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespDataFwded(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespDataFwded\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2314: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataToBeSharedClean)) {
    panic("Runtime Error at CHI-cache-actions.sm:2317: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2318: %s.\n", "assert failure");

}
#endif
;
bool keepData
 = (((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) || ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
    if (keepData) {
            if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_Fwded_SD_PD;
            } else {
                    if (((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_PD_Fwded_SC;
                    } else {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_SC_Fwded_SC;
                    }
                }
            } else {
                    if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                        (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_Fwded_SD_PD;
                    } else {
                            if (((*m_tbe_ptr).m_dataDirty && ((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_PD_Fwded_SC;
                            } else {
                                (*m_tbe_ptr).m_snd_msgType = CHIDataType_SnpRespData_I_Fwded_SC;
                            }
                        }
                    }
                    (*m_tbe_ptr).m_snd_destination = (*m_tbe_ptr).m_requestor;
                    (setupPendingSend(m_tbe_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespDataFwded: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_FwdSnpResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_FwdSnpResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2347: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2348: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    bool keepData
     = (((((*m_tbe_ptr).m_dir_sharers).count()) > (0)) || ((*m_tbe_ptr).m_dataToBeInvalid == (false)));
        if ((keepData && (*m_tbe_ptr).m_dataToBeSharedClean)) {
            #ifndef NDEBUG
            if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_SnpSharedFwd) || ((*m_tbe_ptr).m_reqType == CHIRequestType_SnpNotSharedDirtyFwd)))) {
                panic("Runtime Error at CHI-cache-actions.sm:2361: %s.\n", "assert failure");

            }
            #endif
            ;
            #ifndef NDEBUG
            if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                panic("Runtime Error at CHI-cache-actions.sm:2362: %s.\n", "assert failure");

            }
            #endif
            ;
                if (((*m_tbe_ptr).m_fwdedState == Cache_State_SD)) {
                    (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_SD_PD;
                } else {
                    #ifndef NDEBUG
                    if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_SC))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2366: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                    (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_SC;
                }
            } else {
                    if (keepData) {
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpOnceFwd))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2371: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_I))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2372: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if (((*m_tbe_ptr).m_dataUnique && ((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream))) {
                                (*out_msg).m_type = CHIResponseType_SnpResp_UD_Fwded_I;
                            } else {
                                    if ((*m_tbe_ptr).m_dataUnique) {
                                        (*out_msg).m_type = CHIResponseType_SnpResp_UC_Fwded_I;
                                    } else {
                                            if (((*m_tbe_ptr).m_dataDirty || (*m_tbe_ptr).m_dataMaybeDirtyUpstream)) {
                                                (*out_msg).m_type = CHIResponseType_SnpResp_SD_Fwded_I;
                                            } else {
                                                (*out_msg).m_type = CHIResponseType_SnpResp_SC_Fwded_I;
                                            }
                                        }
                                    }
                                } else {
                                    #ifndef NDEBUG
                                    if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_SnpUniqueFwd))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:2384: %s.\n", "assert failure");

                                    }
                                    #endif
                                    ;
                                    #ifndef NDEBUG
                                    if (!(((*m_tbe_ptr).m_dataMaybeDirtyUpstream == (false)))) {
                                        panic("Runtime Error at CHI-cache-actions.sm:2385: %s.\n", "assert failure");

                                    }
                                    #endif
                                    ;
                                        if (((*m_tbe_ptr).m_fwdedState == Cache_State_UD)) {
                                            (*out_msg).m_type = CHIResponseType_SnpResp_I_Fwded_UD_PD;
                                        } else {
                                            #ifndef NDEBUG
                                            if (!(((*m_tbe_ptr).m_fwdedState == Cache_State_UC))) {
                                                panic("Runtime Error at CHI-cache-actions.sm:2389: %s.\n", "assert failure");

                                            }
                                            #endif
                                            ;
                                            (*out_msg).m_type = CHIResponseType_SnpResp_I_Fwded_UC;
                                        }
                                    }
                                }
                                ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
                            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_FwdSnpResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Data(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Data\n");
    try {
       #ifndef NDEBUG
if (!((*m_tbe_ptr).m_snd_pendEv)) {
    panic("Runtime Error at CHI-cache-actions.sm:2397: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*m_tbe_ptr).m_snd_pendBytes).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2398: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_snd_pendEv = (false);
{
    std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(clockEdge());
    (*out_msg).m_addr = (*m_tbe_ptr).m_addr;
    (*out_msg).m_type = (*m_tbe_ptr).m_snd_msgType;
    int offset
     = (((*m_tbe_ptr).m_snd_pendBytes).firstBitSet((true)));
    #ifndef NDEBUG
    if (!((offset < (*m_blockSize_ptr)))) {
        panic("Runtime Error at CHI-cache-actions.sm:2405: %s.\n", "assert failure");

    }
    #endif
    ;
    int range
     = ((((*m_tbe_ptr).m_snd_pendBytes).firstBitSet((false), offset)) - offset);
    #ifndef NDEBUG
    if (!(((range > (0)) && (range <= (*m_blockSize_ptr))))) {
        panic("Runtime Error at CHI-cache-actions.sm:2407: %s.\n", "assert failure");

    }
    #endif
    ;
        if ((range > m_data_channel_size)) {
            range = m_data_channel_size;
        }
        (((*m_tbe_ptr).m_snd_pendBytes).setMask(offset, range, (false)));
        (*out_msg).m_dataBlk = (*m_tbe_ptr).m_dataBlk;
        (((*out_msg).m_bitMask).setMask(offset, range));
        (*out_msg).m_responder = m_machineID;
        (((*out_msg).m_Destination).add((*m_tbe_ptr).m_snd_destination));
        ((*m_datOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_data_latency)));
    }
    (scheduleSendData(m_tbe_ptr, (1)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Data: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_RespSepData(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_RespSepData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2426: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_RespSepData;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_RespSepData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompI(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompI\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2436: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_I;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompI: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompUC(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompUC\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2446: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_UC;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompUC: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompAck\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2456: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompAck;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((mapAddressToDownstreamMachine((*m_tbe_ptr).m_addr))));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompI_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompI_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2466: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp_I;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompI_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompDBIDResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompDBIDResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2479: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompDBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompDBIDResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_CompDBIDResp_Stale(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_CompDBIDResp_Stale\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2489: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_CompDBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    (*out_msg).m_stale = (true);
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_CompDBIDResp_Stale: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_DBIDResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_DBIDResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2502: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_DBIDResp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_DBIDResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_Comp_WU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_Comp_WU\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2512: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_Comp;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((m_comp_wu_latency + m_response_latency))));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_Comp_WU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_SnpRespI(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_SnpRespI\n");
    try {
       {
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_type = CHIResponseType_SnpResp_I;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_requestor));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_SnpRespI: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_RetryAck(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_RetryAck\n");
    try {
       {
    // Declare message
    GEM5_VAR_USED const Cache_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const Cache_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
    (*out_msg).m_type = CHIResponseType_RetryAck;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_RetryAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Send_PCrdGrant(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Send_PCrdGrant\n");
    try {
       {
    // Declare message
    GEM5_VAR_USED const Cache_RetryTriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const Cache_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(clockEdge());
    (*out_msg).m_addr = ((*in_msg_ptr)).m_addr;
    (*out_msg).m_type = CHIResponseType_PCrdGrant;
    (*out_msg).m_responder = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_retryDest));
    ((*m_rspOut_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_response_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Send_PCrdGrant: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckUpgrade_FromStore(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckUpgrade_FromStore\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2560: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataUnique) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2563: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendReadUnique));
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckUpgrade_FromStore: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckUpgrade_FromCU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckUpgrade_FromCU\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2571: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_dataUnique == (false))) {
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).isElement((*m_tbe_ptr).m_requestor)) == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2574: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_requestorToBeExclusiveOwner = (false);
        (*m_tbe_ptr).m_updateDirOnCompAck = (false);
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckUpgrade_FromCU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckUpgrade_FromRU(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckUpgrade_FromRU\n");
    try {
       #ifndef NDEBUG
if (!((m_is_HN == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2583: %s.\n", "assert failure");

}
#endif
;
    if ((*m_tbe_ptr).m_dataUnique) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2586: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendReadUnique));
    }
    (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_SendCompAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckUpgrade_FromRU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_UpdateCacheFromTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_UpdateCacheFromTBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2595: %s.\n", "assert failure");

}
#endif
;
Cache_State final
 = (*m_tbe_ptr).m_finalState;
    if ((((((((((((((final == Cache_State_UD_RSC) || (final == Cache_State_SD_RSC)) || (final == Cache_State_UC_RSC)) || (final == Cache_State_SC_RSC)) || (final == Cache_State_UD)) || (final == Cache_State_UD_T)) || (final == Cache_State_SD)) || (final == Cache_State_UC)) || (final == Cache_State_SC)) || (final == Cache_State_UC_RU)) || (final == Cache_State_UD_RU)) || (final == Cache_State_UD_RSD)) || (final == Cache_State_SD_RSD))) {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dataBlkValid).isFull()))) {
            panic("Runtime Error at CHI-cache-actions.sm:2602: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2603: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:2604: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_cache_entry_ptr).m_DataBlk = (*m_tbe_ptr).m_dataBlk;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2606: Cached data %s pfb %s\n", (*m_tbe_ptr).m_dataBlk, (*m_cache_entry_ptr).m_HWPrefetched);
    } else {
        #ifndef NDEBUG
        if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2609: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((m_cache_entry_ptr != NULL)) {
                (((*m_cache_ptr)).deallocate(addr));
                unset_cache_entry(m_cache_entry_ptr);;
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_UpdateCacheFromTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_UpdateDirectoryFromTBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_UpdateDirectoryFromTBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2618: %s.\n", "assert failure");

}
#endif
;
Cache_State final
 = (*m_tbe_ptr).m_finalState;
    if ((((((((((((((final == Cache_State_UD_RSC) || (final == Cache_State_SD_RSC)) || (final == Cache_State_UC_RSC)) || (final == Cache_State_SC_RSC)) || (final == Cache_State_UC_RU)) || (final == Cache_State_UD_RU)) || (final == Cache_State_UD_RSD)) || (final == Cache_State_SD_RSD)) || (final == Cache_State_RU)) || (final == Cache_State_RSC)) || (final == Cache_State_RSD)) || (final == Cache_State_RUSD)) || (final == Cache_State_RUSC))) {
        Cache_DirEntry* dir_entry
         = (getDirEntry(addr));
        #ifndef NDEBUG
        if (!((dir_entry != NULL))) {
            panic("Runtime Error at CHI-cache-actions.sm:2626: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((((*m_tbe_ptr).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-actions.sm:2627: %s.\n", "assert failure");

        }
        #endif
        ;
        (*dir_entry).m_ownerExists = (*m_tbe_ptr).m_dir_ownerExists;
        (*dir_entry).m_ownerIsExcl = (*m_tbe_ptr).m_dir_ownerIsExcl;
        (*dir_entry).m_owner = (*m_tbe_ptr).m_dir_owner;
        (*dir_entry).m_sharers = (*m_tbe_ptr).m_dir_sharers;
    } else {
        #ifndef NDEBUG
        if (!((((*m_tbe_ptr).m_dir_ownerExists == (false)) && (((*m_tbe_ptr).m_dir_sharers).isEmpty())))) {
            panic("Runtime Error at CHI-cache-actions.sm:2633: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((((*m_directory_ptr)).isTagPresent(addr))) {
                (((*m_directory_ptr)).deallocate(addr));
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_UpdateDirectoryFromTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Deallocate_CacheBlock(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Deallocate_CacheBlock\n");
    try {
       #ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2641: %s.\n", "assert failure");

}
#endif
;
(((*m_cache_ptr)).deallocate(addr));
unset_cache_entry(m_cache_entry_ptr);;

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Deallocate_CacheBlock: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Allocate_DirEntry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Allocate_DirEntry\n");
    try {
       #ifndef NDEBUG
if (!(((((*m_directory_ptr)).isTagPresent(addr)) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2647: %s.\n", "assert failure");

}
#endif
;
(((*m_directory_ptr)).allocate(addr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Allocate_DirEntry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Deallocate_DirEntry(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Deallocate_DirEntry\n");
    try {
       #ifndef NDEBUG
if (!((((*m_directory_ptr)).isTagPresent(addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2652: %s.\n", "assert failure");

}
#endif
;
(((*m_directory_ptr)).deallocate(addr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Deallocate_DirEntry: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::CheckCacheFill(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing CheckCacheFill\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2657: %s.\n", "assert failure");

}
#endif
;
bool need_fill
 = (((*m_tbe_ptr).m_dataValid && ((*m_tbe_ptr).m_dataToBeInvalid == (false))) && (*m_tbe_ptr).m_doCacheFill);
bool execute_next
 = (true);
    if ((need_fill && (m_cache_entry_ptr != NULL))) {
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_DataArrayWrite));
        (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_FillPipe));
    } else {
            if ((need_fill && (((*m_cache_ptr)).cacheAvail(addr)))) {
                set_cache_entry(m_cache_entry_ptr, (((*m_cache_ptr)).allocate(addr, new Cache_CacheEntry)));;
                (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_DataArrayWriteOnFill));
                (((*m_tbe_ptr).m_actions).pushFront(Cache_Event_FillPipe));
            } else {
                    if (need_fill) {
                        execute_next = (false);
                        Addr victim_addr
                         = (((*m_cache_ptr)).cacheProbe(addr));
                        Cache_CacheEntry* victim_entry
                         = (getCacheEntry(victim_addr));
                        #ifndef NDEBUG
                        if (!((victim_entry != NULL))) {
                            panic("Runtime Error at CHI-cache-actions.sm:2682: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        Cache_TBE* victim_tbe
                         = (getCurrentActiveTBE(victim_addr));
                            if (((victim_tbe == NULL) && (victim_entry != NULL))) {
                                DPRINTF(RubySlicc, "CHI-cache-actions.sm:2688: Eviction for %#x victim: %#x state=%s\n", addr, victim_addr, (*victim_entry).m_state);
                                {
                                    std::shared_ptr<Cache_ReplacementMsg> out_msg = std::make_shared<Cache_ReplacementMsg>(clockEdge());
                                    (*out_msg).m_addr = victim_addr;
                                    (*out_msg).m_from_addr = addr;
                                        if (m_unify_repl_TBEs) {
                                            (*out_msg).m_slot = (*m_tbe_ptr).m_storSlot;
                                            DPRINTF(RubySlicc, "CHI-cache-actions.sm:2695: Reusing slot %d\n", (*out_msg).m_slot);
                                        }
                                        ((*m_replTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
                                    }
                                } else {
                                    DPRINTF(RubySlicc, "CHI-cache-actions.sm:2699: Eviction for %#x victim: %#x state=%s\n", addr, victim_addr, (*victim_tbe).m_state);
                                    (*victim_tbe).m_wakeup_pending_tgr = (true);
                                }
                                        stallBuffer(&((*m_triggerQueue_ptr)), victim_addr);
                                        (*m_triggerQueue_ptr).stallMessage(victim_addr, clockEdge());
                                        
                            }
                        }
                    }
                        if (execute_next) {
                            (((*m_triggerQueue_ptr)).dequeue((clockEdge())));
                            (clearPendingAction(m_tbe_ptr));
                            (processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));
                        } else {
                            (wakeupPendingSnps(m_tbe_ptr));
                        }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:CheckCacheFill: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Finalize_DeallocateRequest(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Finalize_DeallocateRequest\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2721: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_actions).empty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2722: %s.\n", "assert failure");

}
#endif
;
(wakeupPendingReqs(m_tbe_ptr));
(wakeupPendingSnps(m_tbe_ptr));
(wakeupPendingTgrs(m_tbe_ptr));
    if ((*m_tbe_ptr).m_is_req_tbe) {
        (deallocateReqTBE(m_tbe_ptr));
        (processRetryQueue());
    } else {
            if ((*m_tbe_ptr).m_is_snp_tbe) {
                (deallocateSnpTBE(m_tbe_ptr));
            } else {
                (deallocateReplacementTBE(m_tbe_ptr));
                    if (m_unify_repl_TBEs) {
                        (processRetryQueue());
                    }
                }
            }
            unset_tbe(m_tbe_ptr);;
            (incomingTransactionEnd(addr, (curTransitionNextState())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Finalize_DeallocateRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_ReqRdyQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_ReqRdyQueue\n");
    try {
       (((*m_reqRdy_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_ReqRdyQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_RespInQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RespInQueue\n");
    try {
       (((*m_rspIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_RespInQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_SnoopRdyQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_SnoopRdyQueue\n");
    try {
       (((*m_snpRdy_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_SnoopRdyQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_DataInQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_DataInQueue\n");
    try {
       (((*m_datIn_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_DataInQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_TriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_TriggerQueue\n");
    try {
       (((*m_triggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_TriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_ReplTriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_ReplTriggerQueue\n");
    try {
       (((*m_replTriggerQueue_ptr)).dequeue((clockEdge())));
        wakeUpBuffer(&((*m_triggerQueue_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_ReplTriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Pop_RetryTriggerQueue(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Pop_RetryTriggerQueue\n");
    try {
       (((*m_retryTriggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Pop_RetryTriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ProcessNextState(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2779: %s.\n", "assert failure");

}
#endif
;
(processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ProcessNextState: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ProcessNextState_ClearPending(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ProcessNextState_ClearPending\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2784: %s.\n", "assert failure");

}
#endif
;
(clearPendingAction(m_tbe_ptr));
(processNextState(addr, m_tbe_ptr, m_cache_entry_ptr));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ProcessNextState_ClearPending: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_LoadHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_LoadHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2790: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_reqType == CHIRequestType_Load))) {
    panic("Runtime Error at CHI-cache-actions.sm:2791: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2793: %s.\n", "assert failure");

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2794: Read data %s\n", (*m_tbe_ptr).m_dataBlk);
        (((*m_sequencer_ptr)).readCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (false)));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_LoadHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_StoreHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_StoreHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2800: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2802: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_is_local_pf == (false))) {
        #ifndef NDEBUG
        if (!((*m_tbe_ptr).m_dataValid)) {
            panic("Runtime Error at CHI-cache-actions.sm:2804: %s.\n", "assert failure");

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2805: Write before %s\n", (*m_tbe_ptr).m_dataBlk);
        (((*m_sequencer_ptr)).writeCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (false)));
        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2807: Write after %s\n", (*m_tbe_ptr).m_dataBlk);
        (*m_tbe_ptr).m_dataDirty = (true);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_StoreHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_ExpressPrefetchHit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_ExpressPrefetchHit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr == NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2814: %s.\n", "assert failure");

}
#endif
;
(((*m_storTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-actions.sm:2816: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(m_use_prefetcher)) {
    panic("Runtime Error at CHI-cache-actions.sm:2817: %s.\n", "assert failure");

}
#endif
;
(((*m_cache_ptr)).profilePrefetchHit());
{
    // Declare message
    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!(((*in_msg_ptr)).m_is_local_pf)) {
    panic("Runtime Error at CHI-cache-actions.sm:2821: %s.\n", "assert failure");

}
#endif
;
(notifyPfComplete(((*in_msg_ptr)).m_addr));
}

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_ExpressPrefetchHit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_Miss\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2830: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_dataValid && (*m_tbe_ptr).m_is_local_pf)) {
        #ifndef NDEBUG
        if (!(m_use_prefetcher)) {
            panic("Runtime Error at CHI-cache-actions.sm:2832: %s.\n", "assert failure");

        }
        #endif
        ;
        (notifyPfComplete((*m_tbe_ptr).m_addr));
    } else {
            if (((*m_tbe_ptr).m_dataValid && ((*m_tbe_ptr).m_reqType == CHIRequestType_Load))) {
                DPRINTF(RubySlicc, "CHI-cache-actions.sm:2836: Read data %s\n", (*m_tbe_ptr).m_dataBlk);
                (((*m_sequencer_ptr)).readCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (true)));
            } else {
                    if (((*m_tbe_ptr).m_dataValid && (((*m_tbe_ptr).m_reqType == CHIRequestType_Store) || ((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine)))) {
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2841: Write before %s\n", (*m_tbe_ptr).m_dataBlk);
                        (((*m_sequencer_ptr)).writeCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk, (true)));
                        DPRINTF(RubySlicc, "CHI-cache-actions.sm:2843: Write after %s\n", (*m_tbe_ptr).m_dataBlk);
                        (*m_tbe_ptr).m_dataDirty = (true);
                        int use_timeout_latency
                         = (scLockLatency());
                            if ((use_timeout_latency > (0))) {
                                    if ((*m_tbe_ptr).m_hasUseTimeout) {
                                        #ifndef NDEBUG
                                        if (!((((*m_useTimerTable_ptr)).isSet((*m_tbe_ptr).m_addr)))) {
                                            panic("Runtime Error at CHI-cache-actions.sm:2850: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                    } else {
                                        (((*m_useTimerTable_ptr)).set((*m_tbe_ptr).m_addr, ((clockEdge()) + (cyclesToTicks((intToCycles(use_timeout_latency)))))));
                                        (*m_tbe_ptr).m_hasUseTimeout = (true);
                                    }
                                    (scLockDecayLatency());
                                }
                            }
                        }
                    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Unset_Timeout_TBE(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Unset_Timeout_TBE\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2864: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_hasUseTimeout)) {
    panic("Runtime Error at CHI-cache-actions.sm:2865: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_useTimerTable_ptr)).isSet((*m_tbe_ptr).m_addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2866: %s.\n", "assert failure");

}
#endif
;
(((*m_useTimerTable_ptr)).unset((*m_tbe_ptr).m_addr));
(*m_tbe_ptr).m_hasUseTimeout = (false);
        wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Unset_Timeout_TBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Unset_Timeout_Cache(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Unset_Timeout_Cache\n");
    try {
       #ifndef NDEBUG
if (!((((*m_useTimerTable_ptr)).isSet(addr)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2874: %s.\n", "assert failure");

}
#endif
;
(((*m_useTimerTable_ptr)).unset(addr));
        wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
        

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Unset_Timeout_Cache: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Callback_WriteUnique(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Callback_WriteUnique\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2880: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2881: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2883: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*m_tbe_ptr).m_dataValid == (false)))) {
    panic("Runtime Error at CHI-cache-actions.sm:2884: %s.\n", "assert failure");

}
#endif
;
(((*m_sequencer_ptr)).writeUniqueCallback((*m_tbe_ptr).m_addr, (*m_tbe_ptr).m_dataBlk));
DPRINTF(RubySlicc, "CHI-cache-actions.sm:2886: WriteUnique data %s\n", (*m_tbe_ptr).m_dataBlk);
#ifndef NDEBUG
if (!((((*m_tbe_ptr).m_dataBlkValid).isEmpty()))) {
    panic("Runtime Error at CHI-cache-actions.sm:2888: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_dataBlkValid).setMask((addressOffset((*m_tbe_ptr).m_accAddr, (*m_tbe_ptr).m_addr)), (*m_tbe_ptr).m_accSize));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Callback_WriteUnique: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Miss(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Miss\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2893: %s.\n", "assert failure");

}
#endif
;
bool is_demand
 = (((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false));
bool is_remote_can_notify
 = ((*m_tbe_ptr).m_is_remote_pf && m_upstream_prefetch_trains_prefetcher);
    if (is_demand) {
        (((*m_cache_ptr)).profileDemandMiss());
    } else {
        #ifndef NDEBUG
        if (!((m_use_prefetcher || (*m_tbe_ptr).m_is_remote_pf))) {
            panic("Runtime Error at CHI-cache-actions.sm:2899: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_cache_ptr)).profilePrefetchMiss());
    }
        if (((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid) && (is_demand || is_remote_can_notify))) {
            bool is_read
             = (false);
                if ((isReadReqType((*m_tbe_ptr).m_reqType))) {
                    is_read = (true);
                } else {
                    #ifndef NDEBUG
                    if (!((isWriteReqType((*m_tbe_ptr).m_reqType)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2908: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                }
                (notifyPfMiss((*m_tbe_ptr).m_seqReq, is_read, (*m_tbe_ptr).m_dataBlk));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Miss: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Hit(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Hit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2918: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2919: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_dataValid)) {
    panic("Runtime Error at CHI-cache-actions.sm:2920: %s.\n", "assert failure");

}
#endif
;
bool is_demand
 = (((*m_tbe_ptr).m_is_local_pf || (*m_tbe_ptr).m_is_remote_pf) == (false));
bool is_remote_can_notify
 = ((*m_tbe_ptr).m_is_remote_pf && m_upstream_prefetch_trains_prefetcher);
    if (is_demand) {
        (((*m_cache_ptr)).profileDemandHit());
    } else {
        #ifndef NDEBUG
        if (!((m_use_prefetcher || (*m_tbe_ptr).m_is_remote_pf))) {
            panic("Runtime Error at CHI-cache-actions.sm:2926: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_cache_ptr)).profilePrefetchHit());
    }
        if (((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid) && (is_demand || is_remote_can_notify))) {
            bool is_read
             = (false);
                if ((isReadReqType((*m_tbe_ptr).m_reqType))) {
                    is_read = (true);
                } else {
                    #ifndef NDEBUG
                    if (!((isWriteReqType((*m_tbe_ptr).m_reqType)))) {
                        panic("Runtime Error at CHI-cache-actions.sm:2935: %s.\n", "assert failure");

                    }
                    #endif
                    ;
                }
                (notifyPfHit((*m_tbe_ptr).m_seqReq, is_read, (*m_tbe_ptr).m_dataBlk));
                (*m_cache_entry_ptr).m_HWPrefetched = (false);
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Hit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Fill(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Fill\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2944: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2945: %s.\n", "assert failure");

}
#endif
;
    if ((m_use_prefetcher && (*m_tbe_ptr).m_isSeqReqValid)) {
        (*m_cache_entry_ptr).m_HWPrefetched = ((*m_tbe_ptr).m_is_local_pf || ((*m_tbe_ptr).m_is_remote_pf && (m_upstream_prefetch_trains_prefetcher == (false))));
        (notifyPfFill((*m_tbe_ptr).m_seqReq, (*m_tbe_ptr).m_dataBlk, (*m_tbe_ptr).m_is_local_pf));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Fill: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_Eviction(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_Eviction\n");
    try {
           if ((m_sc_lock_enabled && (((*m_sequencer_ptr)).llscCheckMonitor(addr)))) {
        DPRINTF(LLSC, "CHI-cache-actions.sm:2960: Invalidating monitored address %#x\n", addr);
        (scLockIncLatency());
    }
        if (m_send_evictions) {
            DPRINTF(RubySlicc, "CHI-cache-actions.sm:2964: Sending invalidation for %#x to the sequencer\n", addr);
            (((*m_sequencer_ptr)).evictionCallback(addr));
        }
            if ((m_use_prefetcher && (m_cache_entry_ptr != NULL))) {
                (notifyPfEvict(addr, (*m_cache_entry_ptr).m_HWPrefetched));
            }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_Eviction: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingStart(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingStart\n");
    try {
       (outgoingTransactionStart(addr, (curTransitionEvent())));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingStart: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DataResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DataResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2977: %s.\n", "assert failure");

}
#endif
;
    if ((((*m_tbe_ptr).m_expected_req_resp).hasReceivedData())) {
        (outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DataResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::Profile_OutgoingEnd_DatalessResp(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing Profile_OutgoingEnd_DatalessResp\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2985: %s.\n", "assert failure");

}
#endif
;
(outgoingTransactionEnd(addr, (*m_tbe_ptr).m_rcvdRetryAck));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:Profile_OutgoingEnd_DatalessResp: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::TagArrayRead(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing TagArrayRead\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2990: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((tagLatency(((((*m_tbe_ptr).m_reqType == CHIRequestType_Load) || ((*m_tbe_ptr).m_reqType == CHIRequestType_Store)) || ((*m_tbe_ptr).m_reqType == CHIRequestType_StoreLine)))))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:TagArrayRead: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::TagArrayWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing TagArrayWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:2998: %s.\n", "assert failure");

}
#endif
;
    if ((m_dealloc_wait_for_tag && ((*m_tbe_ptr).m_hasUseTimeout == (false)))) {
        (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((tagLatency((false))))));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:TagArrayWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DataArrayRead(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DataArrayRead\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3008: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((dataLatency()))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DataArrayRead: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::DataArrayWrite(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing DataArrayWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3013: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((m_cache_entry_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3014: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_doCacheFill)) {
    panic("Runtime Error at CHI-cache-actions.sm:3015: %s.\n", "assert failure");

}
#endif
;
    if (m_wait_for_cache_wr) {
        (*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((dataLatency()))));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Cache:DataArrayWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ReadHitPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ReadHitPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3022: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_read_hit_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ReadHitPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::ReadMissPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ReadMissPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3027: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_read_miss_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:ReadMissPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::WriteFEPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing WriteFEPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3032: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_write_fe_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:WriteFEPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::WriteBEPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing WriteBEPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3037: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_write_be_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:WriteBEPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::FillPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing FillPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3042: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_fill_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:FillPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpSharedPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpSharedPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3047: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_snp_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpSharedPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpInvPipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpInvPipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3052: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks((m_snp_latency + m_snp_inv_latency))));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpInvPipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief  */
void
Cache_Controller::SnpOncePipe(Cache_TBE*& m_tbe_ptr, Cache_CacheEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing SnpOncePipe\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at CHI-cache-actions.sm:3057: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_delayNextAction = ((curTick()) + (cyclesToTicks(m_snp_latency)));

    } catch (const RejectException & e) {
       fatal("Error in action Cache:SnpOncePipe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

void
Cache_Controller::notifyPfHit(const RequestPtr& param_req, const bool& param_is_read, const DataBlock& param_blk)
{

}
void
Cache_Controller::notifyPfMiss(const RequestPtr& param_req, const bool& param_is_read, const DataBlock& param_blk)
{

}
void
Cache_Controller::notifyPfFill(const RequestPtr& param_req, const DataBlock& param_blk, const bool& param_from_pf)
{

}
void
Cache_Controller::notifyPfEvict(const Addr& param_blkAddr, const bool& param_hwPrefetched)
{

}
void
Cache_Controller::notifyPfComplete(const Addr& param_addr)
{

}
Cache_CacheEntry*
Cache_Controller::getCacheEntry(const Addr& param_addr)
{
return static_cast<Cache_CacheEntry *>((((*m_cache_ptr)).lookup(param_addr)));

}
Cache_DirEntry*
Cache_Controller::getDirEntry(const Addr& param_addr)
{
    if ((((*m_directory_ptr)).isTagPresent(param_addr))) {
        return (((*m_directory_ptr)).lookup(param_addr));
    } else {
        return NULL;
    }

}
Cache_State
Cache_Controller::getState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, const Addr& param_addr)
{
    if ((param_tbe != NULL)) {
        return (*param_tbe).m_state;
    } else {
            if ((param_cache_entry != NULL)) {
                return (*param_cache_entry).m_state;
            } else {
                Cache_DirEntry* dir_entry
                 = (getDirEntry(param_addr));
                    if ((dir_entry != NULL)) {
                        return (*dir_entry).m_state;
                    } else {
                        return Cache_State_I;
                    }
                }
            }

}
void
Cache_Controller::setState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, const Addr& param_addr, const Cache_State& param_state)
{
    if ((param_tbe != NULL)) {
        (*param_tbe).m_state = param_state;
    }
        if ((param_cache_entry != NULL)) {
            (*param_cache_entry).m_state = param_state;
        }
        Cache_DirEntry* dir_entry
         = (getDirEntry(param_addr));
            if ((dir_entry != NULL)) {
                (*dir_entry).m_state = param_state;
            }

}
Cache_TBE*
Cache_Controller::getCurrentActiveTBE(const Addr& param_addr)
{
Cache_TBE* snp_tbe
 = (((*m_snpTBEs_ptr)).lookup(param_addr));
    if ((snp_tbe != NULL)) {
        return snp_tbe;
    }
    Cache_TBE* req_tbe
     = (((*m_TBEs_ptr)).lookup(param_addr));
    Cache_TBE* repl_tbe
     = (((*m_replTBEs_ptr)).lookup(param_addr));
        if ((req_tbe != NULL)) {
            #ifndef NDEBUG
            if (!((repl_tbe == NULL))) {
                panic("Runtime Error at CHI-cache-funcs.sm:124: %s.\n", "assert failure");

            }
            #endif
            ;
            return req_tbe;
        }
            if ((repl_tbe != NULL)) {
                #ifndef NDEBUG
                if (!((req_tbe == NULL))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:128: %s.\n", "assert failure");

                }
                #endif
                ;
                return repl_tbe;
            }
            return NULL;

}
AccessPermission
Cache_Controller::getAccessPermission(const Addr& param_addr)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
    if ((tbe != NULL)) {
        #ifndef NDEBUG
        if (!(((Cache_State_to_permission((*tbe).m_state)) == AccessPermission_Busy))) {
            panic("Runtime Error at CHI-cache-funcs.sm:137: %s.\n", "assert failure");

        }
        #endif
        ;
            if (((((*tbe).m_expected_req_resp).hasExpected()) || (((*tbe).m_expected_snp_resp).hasExpected()))) {
                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:140: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Busy);
                return AccessPermission_Busy;
            } else {
                    if (((*tbe).m_dataValid && ((*tbe).m_dataMaybeDirtyUpstream == (false)))) {
                            if ((*tbe).m_dataUnique) {
                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:145: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Read_Write);
                                return AccessPermission_Read_Write;
                            } else {
                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:148: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Read_Only);
                                return AccessPermission_Read_Only;
                            }
                        } else {
                            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:152: %x %s,%s\n", param_addr, (*tbe).m_state, AccessPermission_Busy);
                            return AccessPermission_Busy;
                        }
                    }
                }
                Cache_CacheEntry* cache_entry
                 = (getCacheEntry(param_addr));
                    if ((cache_entry != NULL)) {
                        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:158: %x %s,%s\n", param_addr, (*cache_entry).m_state, (Cache_State_to_permission((*cache_entry).m_state)));
                        return (Cache_State_to_permission((*cache_entry).m_state));
                    }
                    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:161: %x %s,%s\n", param_addr, Cache_State_I, AccessPermission_NotPresent);
                    return AccessPermission_NotPresent;

}
void
Cache_Controller::setAccessPermission(Cache_CacheEntry* param_cache_entry, const Addr& param_addr, const Cache_State& param_state)
{
    if ((param_cache_entry != NULL)) {
        ((*(param_cache_entry)).changePermission((Cache_State_to_permission(param_state))));
    }

}
void
Cache_Controller::functionalRead(const Addr& param_addr, Packet* param_pkt, WriteMask& param_mask)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
Cache_CacheEntry* cache_entry
 = (getCacheEntry(param_addr));
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:176: functionalRead %x\n", param_addr);
WriteMask read_mask;
bool dirty
 = (false);
bool from_tbe
 = (false);
    if ((tbe != NULL)) {
        from_tbe = (true);
        dirty = (*tbe).m_dataDirty;
            if ((*tbe).m_dataValid) {
                ((read_mask).fillMask());
            } else {
                read_mask = (*tbe).m_dataBlkValid;
                dirty = (((((((((((((dirty || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CompData_UD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CompData_SD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CBWrData_UD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_CBWrData_SD_PD))) || (((*tbe).m_expected_req_resp).receivedDataType(CHIDataType_NCBWrData))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_UD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_Fwded_SD_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_SC_PD_Fwded_SC))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_Fwded_SD_PD))) || (((*tbe).m_expected_snp_resp).receivedDataType(CHIDataType_SnpRespData_I_PD_Fwded_SC)));
            }
        } else {
                if (((cache_entry != NULL) && (((Cache_State_to_permission((*cache_entry).m_state)) == AccessPermission_Read_Write) || ((Cache_State_to_permission((*cache_entry).m_state)) == AccessPermission_Read_Only)))) {
                    from_tbe = (false);
                    ((read_mask).fillMask());
                    dirty = (((((((((*cache_entry).m_state == Cache_State_UD) || ((*cache_entry).m_state == Cache_State_UD_RSC)) || ((*cache_entry).m_state == Cache_State_SD)) || ((*cache_entry).m_state == Cache_State_SD_RSC)) || ((*cache_entry).m_state == Cache_State_UD_RU)) || ((*cache_entry).m_state == Cache_State_UD_RSD)) || ((*cache_entry).m_state == Cache_State_SD_RSD)) || ((*cache_entry).m_state == Cache_State_UD_T));
                }
            }
            WriteMask test_mask
             = param_mask;
            ((test_mask).orMask(read_mask));
                if (((((param_mask).containsMask(test_mask)) == (false)) || dirty)) {
                        if (from_tbe) {
                                if ((testAndReadMask(param_addr, (*tbe).m_dataBlk, read_mask, param_pkt))) {
                                    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:221: functionalRead tbe %x %s dirty=%d %s %s\n", param_addr, (*tbe).m_dataBlk, (*tbe).m_dataDirty, read_mask, param_mask);
                                    ((param_mask).orMask(read_mask));
                                }
                            } else {
                                    if ((testAndReadMask(param_addr, (*cache_entry).m_DataBlk, read_mask, param_pkt))) {
                                        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:226: functionalRead cache %x %s dirty=%d %s %s\n", param_addr, (*cache_entry).m_DataBlk, dirty, read_mask, param_mask);
                                        ((param_mask).orMask(read_mask));
                                    }
                                }
                            }

}
int
Cache_Controller::functionalWrite(const Addr& param_addr, Packet* param_pkt)
{
int num_functional_writes
 = (0);
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_addr));
    if ((tbe != NULL)) {
        num_functional_writes = (num_functional_writes + (testAndWrite(param_addr, (*tbe).m_dataBlk, param_pkt)));
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:239: functionalWrite tbe %x %s\n", param_addr, (*tbe).m_dataBlk);
    }
    Cache_CacheEntry* cache_entry
     = (getCacheEntry(param_addr));
        if ((cache_entry != NULL)) {
            num_functional_writes = (num_functional_writes + (testAndWrite(param_addr, (*cache_entry).m_DataBlk, param_pkt)));
            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:245: functionalWrite cache %x %s\n", param_addr, (*cache_entry).m_DataBlk);
        }
        return num_functional_writes;

}
Cycles
Cache_Controller::mandatoryQueueLatency(const RubyRequestType& param_type)
{
return (intToCycles((1)));

}
Cycles
Cache_Controller::tagLatency(const bool& param_from_sequencer)
{
    if (param_from_sequencer) {
        return ((((*m_cache_ptr)).getTagLatency()) - (intToCycles((1))));
    } else {
        return (((*m_cache_ptr)).getTagLatency());
    }

}
Cycles
Cache_Controller::dataLatency()
{
return (((*m_cache_ptr)).getDataLatency());

}
bool
Cache_Controller::inCache(const Addr& param_addr)
{
Cache_CacheEntry* entry
 = (getCacheEntry((makeLineAddress(param_addr))));
    if ((((entry != NULL) == (false)) || ((*entry).m_state == Cache_State_I))) {
        return (false);
    } else {
        return (true);
    }

}
bool
Cache_Controller::hasBeenPrefetched(const Addr& param_addr)
{
Cache_CacheEntry* entry
 = (getCacheEntry((makeLineAddress(param_addr))));
    if ((entry != NULL)) {
        return (*entry).m_HWPrefetched;
    } else {
        return (false);
    }

}
bool
Cache_Controller::inMissQueue(const Addr& param_addr)
{
Addr line_addr
 = (makeLineAddress(param_addr));
Cache_TBE* tbe
 = (getCurrentActiveTBE(line_addr));
return (tbe != NULL);

}
void
Cache_Controller::notifyCoalesced(const Addr& param_addr, const RubyRequestType& param_type, const RequestPtr& param_req, const DataBlock& param_data_blk, const bool& param_was_miss)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:295: notifyCoalesced(addr=%#x, type=%s, was_miss=%d)\n", param_addr, param_type, param_was_miss);
    if (param_was_miss) {
        (((*m_cache_ptr)).profileDemandMiss());
    } else {
        (((*m_cache_ptr)).profileDemandHit());
    }
        if (m_use_prefetcher) {
            bool is_read
             = (((param_type == RubyRequestType_LD) || (param_type == RubyRequestType_Load_Linked)) || (param_type == RubyRequestType_IFETCH));
                if (param_was_miss) {
                    (notifyPfMiss(param_req, is_read, param_data_blk));
                } else {
                    (notifyPfHit(param_req, is_read, param_data_blk));
                }
            }

}
void
Cache_Controller::clearExpectedReqResp(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:320: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:321: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_expected_req_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
Cache_Controller::clearExpectedSnpResp(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:326: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:327: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_expected_snp_resp).clear(((*m_blockSize_ptr) / m_data_channel_size)));

}
void
Cache_Controller::initializeTBE(Cache_TBE* param_tbe, const Addr& param_addr, const int& param_storSlot)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:332: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_wakeup_pending_req = (false);
(*param_tbe).m_wakeup_pending_snp = (false);
(*param_tbe).m_wakeup_pending_tgr = (false);
(*param_tbe).m_addr = param_addr;
(*param_tbe).m_storSlot = param_storSlot;
(clearExpectedReqResp(param_tbe));
(clearExpectedSnpResp(param_tbe));
(*param_tbe).m_defer_expected_comp = (false);
(*param_tbe).m_requestorToBeOwner = (false);
(*param_tbe).m_requestorToBeExclusiveOwner = (false);
(*param_tbe).m_updateDirOnCompAck = (true);
(*param_tbe).m_dataToBeInvalid = (false);
(*param_tbe).m_dataToBeSharedClean = (false);
(*param_tbe).m_doCacheFill = (false);
(*param_tbe).m_pendReqType = CHIRequestType_null;
(*param_tbe).m_pendAction = Cache_Event_null;
(*param_tbe).m_finalState = Cache_State_null;
(*param_tbe).m_delayNextAction = (intToTick((0)));
(*param_tbe).m_is_stale = (false);

}
Cache_TBE*
Cache_Controller::allocateRequestTBE(const Addr& param_addr, const CHIRequestMsg& param_in_msg)
{
(((*m_storTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:367: %s.\n", "assert failure");

}
#endif
;
(((*m_TBEs_ptr)).allocate(param_addr));
Cache_TBE* tbe
 = (((*m_TBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, (((*m_storTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:374: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:375: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_req_tbe = (true);
(*tbe).m_accAddr = (param_in_msg).m_accAddr;
(*tbe).m_accSize = (param_in_msg).m_accSize;
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_isSeqReqValid = (param_in_msg).m_isSeqReqValid;
(*tbe).m_seqReq = (param_in_msg).m_seqReq;
(*tbe).m_is_local_pf = (param_in_msg).m_is_local_pf;
(*tbe).m_is_remote_pf = (param_in_msg).m_is_remote_pf;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
(*tbe).m_hasUseTimeout = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateSnoopTBE(const Addr& param_addr, const CHIRequestMsg& param_in_msg)
{
(((*m_storSnpTBEs_ptr)).decrementReserved());
#ifndef NDEBUG
if (!((((*m_storSnpTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:400: %s.\n", "assert failure");

}
#endif
;
(((*m_snpTBEs_ptr)).allocate(param_addr));
Cache_TBE* tbe
 = (((*m_snpTBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, (((*m_storSnpTBEs_ptr)).addEntryToNewSlot())));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:406: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_repl_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:407: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_snp_tbe = (true);
(*tbe).m_accAddr = param_addr;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = (param_in_msg).m_requestor;
(*tbe).m_fwdRequestor = (param_in_msg).m_fwdRequestor;
(*tbe).m_reqType = (param_in_msg).m_type;
(*tbe).m_snpNeedsData = (param_in_msg).m_retToSrc;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::_allocateReplacementTBE(const Addr& param_addr, const int& param_storSlot)
{
Cache_TBE* tbe
 = (((*m_replTBEs_ptr)).lookup(param_addr));
(initializeTBE(tbe, param_addr, param_storSlot));
#ifndef NDEBUG
if (!(((*tbe).m_is_req_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:429: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_is_snp_tbe == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:430: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_is_repl_tbe = (true);
(*tbe).m_accAddr = param_addr;
(*tbe).m_accSize = (*m_blockSize_ptr);
(*tbe).m_requestor = m_machineID;
(*tbe).m_reqType = CHIRequestType_null;
(*tbe).m_use_DMT = (false);
(*tbe).m_use_DCT = (false);
return tbe;

}
Cache_TBE*
Cache_Controller::allocateReplacementTBE(const Addr& param_addr)
{
#ifndef NDEBUG
if (!((((*m_storReplTBEs_ptr)).areNSlotsAvailable((1))))) {
    panic("Runtime Error at CHI-cache-funcs.sm:446: %s.\n", "assert failure");

}
#endif
;
(((*m_replTBEs_ptr)).allocate(param_addr));
return (_allocateReplacementTBE(param_addr, (((*m_storReplTBEs_ptr)).addEntryToNewSlot())));

}
Cache_TBE*
Cache_Controller::allocateReplacementTBEOnSlot(const Addr& param_addr, const int& param_slot)
{
#ifndef NDEBUG
if (!(m_unify_repl_TBEs)) {
    panic("Runtime Error at CHI-cache-funcs.sm:454: %s.\n", "assert failure");

}
#endif
;
(((*m_storTBEs_ptr)).addEntryToSlot(param_slot));
(((*m_replTBEs_ptr)).allocate(param_addr));
return (_allocateReplacementTBE(param_addr, param_slot));

}
Cache_TBE*
Cache_Controller::getHazardTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:462: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:463: %s.\n", "assert failure");

}
#endif
;
Cache_TBE* hazard_tbe
 = (((*m_TBEs_ptr)).lookup((*param_tbe).m_addr));
    if ((*param_tbe).m_is_req_hazard) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_is_repl_hazard == (false)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:466: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        #ifndef NDEBUG
        if (!((*param_tbe).m_is_repl_hazard)) {
            panic("Runtime Error at CHI-cache-funcs.sm:468: %s.\n", "assert failure");

        }
        #endif
        ;
        hazard_tbe = (((*m_replTBEs_ptr)).lookup((*param_tbe).m_addr));
    }
    #ifndef NDEBUG
    if (!((hazard_tbe != NULL))) {
        panic("Runtime Error at CHI-cache-funcs.sm:471: %s.\n", "assert failure");

    }
    #endif
    ;
    return hazard_tbe;

}
void
Cache_Controller::scheduleSendData(Cache_TBE* param_tbe, const int& param_when)
{
    if (((((*param_tbe).m_snd_pendBytes).count()) > (0))) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_snd_pendEv == (false)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:477: %s.\n", "assert failure");

        }
        #endif
        ;
        (*param_tbe).m_snd_pendEv = (true);
        (*param_tbe).m_pendAction = Cache_Event_TX_Data;
        {
            std::shared_ptr<Cache_TriggerMsg> out_msg = std::make_shared<Cache_TriggerMsg>(clockEdge());
            (*out_msg).m_addr = (*param_tbe).m_addr;
            (*out_msg).m_from_hazard = ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard);
            ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((intToCycles(param_when)))));
        }
    }

}
void
Cache_Controller::setupPendingSend(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:489: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:490: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*param_tbe).m_dataBlkValid).isFull()))) {
    panic("Runtime Error at CHI-cache-funcs.sm:492: %s.\n", "assert failure");

}
#endif
;
(((*param_tbe).m_snd_pendBytes).fillMask());
(scheduleSendData(param_tbe, (0)));

}
void
Cache_Controller::setupPendingPartialSend(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!(((*m_blockSize_ptr) >= m_data_channel_size))) {
    panic("Runtime Error at CHI-cache-funcs.sm:498: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*m_blockSize_ptr) % m_data_channel_size) == (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:499: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*param_tbe).m_dataBlkValid).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:501: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_snd_pendBytes = (*param_tbe).m_dataBlkValid;
(scheduleSendData(param_tbe, (0)));

}
void
Cache_Controller::prepareRequest(Cache_TBE* param_tbe, const CHIRequestType& param_type, CHIRequestMsg& param_out_msg)
{
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_accAddr = (*param_tbe).m_addr;
(param_out_msg).m_accSize = (*m_blockSize_ptr);
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_type = param_type;
(param_out_msg).m_allowRetry = (false);
(*param_tbe).m_pendReqAllowRetry = (false);
(*param_tbe).m_rcvdRetryAck = (false);
(*param_tbe).m_rcvdRetryCredit = (false);
(*param_tbe).m_pendReqType = param_type;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);

}
void
Cache_Controller::allowRequestRetry(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
(param_out_msg).m_allowRetry = (true);
(*param_tbe).m_pendReqAllowRetry = (true);
(*param_tbe).m_pendReqAccAddr = (param_out_msg).m_accAddr;
(*param_tbe).m_pendReqAccSize = (param_out_msg).m_accSize;
(*param_tbe).m_pendReqDest = (param_out_msg).m_Destination;
(*param_tbe).m_pendReqD2OrigReq = (param_out_msg).m_dataToFwdRequestor;
(*param_tbe).m_pendReqRetToSrc = (param_out_msg).m_retToSrc;

}
void
Cache_Controller::prepareRequestRetry(Cache_TBE* param_tbe, CHIRequestMsg& param_out_msg)
{
#ifndef NDEBUG
if (!((*param_tbe).m_pendReqAllowRetry)) {
    panic("Runtime Error at CHI-cache-funcs.sm:536: %s.\n", "assert failure");

}
#endif
;
(*param_tbe).m_pendReqAllowRetry = (false);
(param_out_msg).m_allowRetry = (false);
(param_out_msg).m_addr = (*param_tbe).m_addr;
(param_out_msg).m_requestor = m_machineID;
(param_out_msg).m_fwdRequestor = (*param_tbe).m_requestor;
(param_out_msg).m_accAddr = (*param_tbe).m_pendReqAccAddr;
(param_out_msg).m_accSize = (*param_tbe).m_pendReqAccSize;
(param_out_msg).m_type = (*param_tbe).m_pendReqType;
(param_out_msg).m_Destination = (*param_tbe).m_pendReqDest;
(param_out_msg).m_dataToFwdRequestor = (*param_tbe).m_pendReqD2OrigReq;
(param_out_msg).m_retToSrc = (*param_tbe).m_pendReqRetToSrc;
(param_out_msg).m_isSeqReqValid = (*param_tbe).m_isSeqReqValid;
(param_out_msg).m_seqReq = (*param_tbe).m_seqReq;
(param_out_msg).m_is_local_pf = (false);
(param_out_msg).m_is_remote_pf = ((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf);

}
void
Cache_Controller::enqueueDoRetry(Cache_TBE* param_tbe)
{
    if (((*param_tbe).m_rcvdRetryAck && (*param_tbe).m_rcvdRetryCredit)) {
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_addr = (*param_tbe).m_addr;
            (*out_msg).m_event = Cache_Event_DoRetry;
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
        (((*m_destsWaitingRetry_ptr)).removeNetDest((*param_tbe).m_pendReqDest));
    }

}
void
Cache_Controller::processRetryQueue()
{
bool has_avail
 = (((*m_storTBEs_ptr)).areNSlotsAvailable((1)));
#ifndef NDEBUG
if (!((m_unify_repl_TBEs || has_avail))) {
    panic("Runtime Error at CHI-cache-funcs.sm:568: %s.\n", "assert failure");

}
#endif
;
    if ((((((*m_retryQueue_ptr)).empty()) == (false)) && has_avail)) {
        (((*m_storTBEs_ptr)).incrementReserved());
        Cache_RetryQueueEntry e
         = (((*m_retryQueue_ptr)).next());
        (((*m_retryQueue_ptr)).pop());
        {
            std::shared_ptr<Cache_RetryTriggerMsg> out_msg = std::make_shared<Cache_RetryTriggerMsg>(clockEdge());
            (*out_msg).m_addr = (e).m_addr;
            (*out_msg).m_retryDest = (e).m_retryDest;
            (*out_msg).m_event = Cache_Event_SendPCrdGrant;
            ((*m_retryTriggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((0))));
        }
    }

}
void
Cache_Controller::printResources()
{
    if (m_unify_repl_TBEs) {
        #ifndef NDEBUG
        if (!(((((*m_storReplTBEs_ptr)).size()) == (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:584: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((((*m_storReplTBEs_ptr)).reserved()) == (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:585: %s.\n", "assert failure");

        }
        #endif
        ;
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:586: Resources(used/rsvd/max): TBEs=%d/%d/%d snpTBEs=%d/%d/%d replTBEs=%d/%d/%d\n", (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storSnpTBEs_ptr)).size()), (((*m_storSnpTBEs_ptr)).reserved()), (((*m_storSnpTBEs_ptr)).capacity()), (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()));
    } else {
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:591: Resources(used/rsvd/max): TBEs=%d/%d/%d snpTBEs=%d/%d/%d replTBEs=%d/%d/%d\n", (((*m_storTBEs_ptr)).size()), (((*m_storTBEs_ptr)).reserved()), (((*m_storTBEs_ptr)).capacity()), (((*m_storSnpTBEs_ptr)).size()), (((*m_storSnpTBEs_ptr)).reserved()), (((*m_storSnpTBEs_ptr)).capacity()), (((*m_storReplTBEs_ptr)).size()), (((*m_storReplTBEs_ptr)).reserved()), (((*m_storReplTBEs_ptr)).capacity()));
    }
    DPRINTF(RubySlicc, "CHI-cache-funcs.sm:596: Resources(in/out size): req=%d/%d rsp=%d/%d dat=%d/%d snp=%d/%d trigger=%d\n", (((*m_reqIn_ptr)).getSize((curTick()))), (((*m_reqOut_ptr)).getSize((curTick()))), (((*m_rspIn_ptr)).getSize((curTick()))), (((*m_rspOut_ptr)).getSize((curTick()))), (((*m_datIn_ptr)).getSize((curTick()))), (((*m_datOut_ptr)).getSize((curTick()))), (((*m_snpIn_ptr)).getSize((curTick()))), (((*m_snpOut_ptr)).getSize((curTick()))), (((*m_triggerQueue_ptr)).getSize((curTick()))));

}
bool
Cache_Controller::needCacheEntry(const CHIRequestType& param_req_type, Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry, const bool& param_is_prefetch)
{
    if (((param_cache_entry != NULL) || ((m_enable_DMT && (param_dir_entry == NULL)) && (((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadUnique)) || (param_req_type == CHIRequestType_ReadOnce))))) {
        return (false);
    } else {
        return ((((((param_is_prefetch || (m_alloc_on_readshared && ((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadNotSharedDirty)))) || (m_alloc_on_readunique && (param_req_type == CHIRequestType_ReadUnique))) || (m_alloc_on_readonce && (param_req_type == CHIRequestType_ReadOnce))) || (m_alloc_on_writeback && ((((param_req_type == CHIRequestType_WriteBackFull) || (param_req_type == CHIRequestType_WriteCleanFull)) || (param_req_type == CHIRequestType_WriteEvictFull)) || (m_is_HN && (param_req_type == CHIRequestType_WriteUniqueFull))))) || (m_alloc_on_seq_acc && ((param_req_type == CHIRequestType_Load) || (param_req_type == CHIRequestType_Store)))) || (m_alloc_on_seq_line_write && (param_req_type == CHIRequestType_StoreLine)));
    }

}
bool
Cache_Controller::needDeallocCacheEntry(const CHIRequestType& param_req_type)
{
return ((m_dealloc_on_shared && ((param_req_type == CHIRequestType_ReadShared) || (param_req_type == CHIRequestType_ReadNotSharedDirty))) || (m_dealloc_on_unique && ((param_req_type == CHIRequestType_ReadUnique) || (param_req_type == CHIRequestType_CleanUnique))));

}
bool
Cache_Controller::upstreamHasUnique(const Cache_State& param_state)
{
return (((param_state == Cache_State_RU) || (param_state == Cache_State_UD_RU)) || (param_state == Cache_State_UC_RU));

}
bool
Cache_Controller::upstreamHasShared(const Cache_State& param_state)
{
return ((((((((((param_state == Cache_State_RSC) || (param_state == Cache_State_RSD)) || (param_state == Cache_State_RUSD)) || (param_state == Cache_State_RUSC)) || (param_state == Cache_State_UD_RSD)) || (param_state == Cache_State_SD_RSD)) || (param_state == Cache_State_UD_RSC)) || (param_state == Cache_State_SD_RSC)) || (param_state == Cache_State_UC_RSC)) || (param_state == Cache_State_SC_RSC));

}
void
Cache_Controller::printTBEState(Cache_TBE* param_tbe)
{
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:653: STATE: addr: %#x data present=%d valid=%d unique=%d dirty=%d mu_dirty=%d dir ownerV=%d ownerE=%d sharers=%d tobe_I=%d tobe_SC=%d doFill=%d pendAction=%s\n", (*param_tbe).m_addr, (((*param_tbe).m_dataBlkValid).isFull()), (*param_tbe).m_dataValid, (*param_tbe).m_dataUnique, (*param_tbe).m_dataDirty, (*param_tbe).m_dataMaybeDirtyUpstream, (*param_tbe).m_dir_ownerExists, (*param_tbe).m_dir_ownerIsExcl, (((*param_tbe).m_dir_sharers).count()), (*param_tbe).m_dataToBeInvalid, (*param_tbe).m_dataToBeSharedClean, (*param_tbe).m_doCacheFill, (*param_tbe).m_pendAction);
DPRINTF(RubySlicc, "CHI-cache-funcs.sm:659: dataBlkValid = %s\n", (*param_tbe).m_dataBlkValid);

}
void
Cache_Controller::copyCacheAndDir(Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry, Cache_TBE* param_tbe, const Cache_State& param_initialState)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:664: %s.\n", "assert failure");

}
#endif
;
    if ((param_dir_entry != NULL)) {
        #ifndef NDEBUG
        if (!((((((((((((((param_initialState == Cache_State_UD_RSC) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_SC_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RSC)) || (param_initialState == Cache_State_RSD)) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_RUSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:674: %s.\n", "assert failure");

        }
        #endif
        ;
        (*param_tbe).m_dir_sharers = (*param_dir_entry).m_sharers;
        (*param_tbe).m_dir_owner = (*param_dir_entry).m_owner;
        (*param_tbe).m_dir_ownerExists = (*param_dir_entry).m_ownerExists;
        (*param_tbe).m_dir_ownerIsExcl = (*param_dir_entry).m_ownerIsExcl;
        #ifndef NDEBUG
        if (!(((((*param_tbe).m_dir_sharers).count()) > (0)))) {
            panic("Runtime Error at CHI-cache-funcs.sm:679: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        (((*param_tbe).m_dir_sharers).clear());
        (*param_tbe).m_dir_ownerExists = (false);
    }
    #ifndef NDEBUG
    if (!((((*param_tbe).m_dir_ownerExists && (*param_tbe).m_dir_ownerIsExcl) == (((param_initialState == Cache_State_UD_RU) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU))))) {
        panic("Runtime Error at CHI-cache-funcs.sm:687: %s.\n", "assert failure");

    }
    #endif
    ;
    #ifndef NDEBUG
    if (!((((*param_tbe).m_dir_ownerExists && ((*param_tbe).m_dir_ownerIsExcl == (false))) == ((((param_initialState == Cache_State_RSD) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD))))) {
        panic("Runtime Error at CHI-cache-funcs.sm:690: %s.\n", "assert failure");

    }
    #endif
    ;
        if (((param_cache_entry != NULL) && (((((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_SD)) || (param_initialState == Cache_State_UC)) || (param_initialState == Cache_State_SC)) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_SC_RSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_UD_T)))) {
            (*param_tbe).m_dataBlk = (*param_cache_entry).m_DataBlk;
            (((*param_tbe).m_dataBlkValid).fillMask());
            (*param_tbe).m_dataValid = (true);
            DPRINTF(RubySlicc, "CHI-cache-funcs.sm:703: Cached data %s\n", (*param_tbe).m_dataBlk);
        } else {
            #ifndef NDEBUG
            if (!(((param_cache_entry == NULL) || (((param_cache_entry != NULL) && (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC_RU))))) {
                panic("Runtime Error at CHI-cache-funcs.sm:707: %s.\n", "assert failure");

            }
            #endif
            ;
            (((*param_tbe).m_dataBlkValid).clear());
            (*param_tbe).m_dataValid = (false);
        }
            if (((param_cache_entry != NULL) && (((*param_tbe).m_is_local_pf || (*param_tbe).m_is_remote_pf) == (false)))) {
                (((*m_cache_ptr)).setMRU(param_cache_entry));
            }
            (*param_tbe).m_dataDirty = ((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_SD)) || (param_initialState == Cache_State_SD_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_UD_T));
            (*param_tbe).m_dataMaybeDirtyUpstream = (((((((param_initialState == Cache_State_UD_RU) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_SD_RSD)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RSD)) || (param_initialState == Cache_State_RUSD));
            #ifndef NDEBUG
            if (!(((*param_tbe).m_dir_ownerExists == (*param_tbe).m_dataMaybeDirtyUpstream))) {
                panic("Runtime Error at CHI-cache-funcs.sm:728: %s.\n", "assert failure");

            }
            #endif
            ;
            (*param_tbe).m_dataUnique = (((((((((((param_initialState == Cache_State_UD) || (param_initialState == Cache_State_UD_RSC)) || (param_initialState == Cache_State_UD_RU)) || (param_initialState == Cache_State_UC)) || (param_initialState == Cache_State_UC_RSC)) || (param_initialState == Cache_State_UC_RU)) || (param_initialState == Cache_State_RU)) || (param_initialState == Cache_State_RUSD)) || (param_initialState == Cache_State_RUSC)) || (param_initialState == Cache_State_UD_RSD)) || (param_initialState == Cache_State_UD_T));
            (*param_tbe).m_hasUseTimeout = (param_initialState == Cache_State_UD_T);
            (*param_tbe).m_dataToBeSharedClean = (false);
            (*param_tbe).m_dataToBeInvalid = (false);
            (printTBEState(param_tbe));

}
void
Cache_Controller::copyCacheAndDirTBEs(Cache_TBE* param_src, Cache_TBE* param_dst)
{
#ifndef NDEBUG
if (!((param_src != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:748: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((param_dst != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:749: %s.\n", "assert failure");

}
#endif
;
(*param_dst).m_dataBlk = (*param_src).m_dataBlk;
(*param_dst).m_dataBlkValid = (*param_src).m_dataBlkValid;
(*param_dst).m_dataValid = (*param_src).m_dataValid;
(*param_dst).m_dataDirty = (*param_src).m_dataDirty;
(*param_dst).m_dataMaybeDirtyUpstream = (*param_src).m_dataMaybeDirtyUpstream;
(*param_dst).m_dataUnique = (*param_src).m_dataUnique;
(*param_dst).m_dir_sharers = (*param_src).m_dir_sharers;
(*param_dst).m_dir_owner = (*param_src).m_dir_owner;
(*param_dst).m_dir_ownerExists = (*param_src).m_dir_ownerExists;
(*param_dst).m_dir_ownerIsExcl = (*param_src).m_dir_ownerIsExcl;
(printTBEState(param_dst));

}
void
Cache_Controller::deallocateReqTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:764: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_req_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:765: %s.\n", "assert failure");

}
#endif
;
(((*m_storTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_TBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateSnpTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:771: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_snp_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:772: %s.\n", "assert failure");

}
#endif
;
(((*m_storSnpTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
(((*m_snpTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::deallocateReplacementTBE(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:778: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*param_tbe).m_is_repl_tbe)) {
    panic("Runtime Error at CHI-cache-funcs.sm:779: %s.\n", "assert failure");

}
#endif
;
    if (m_unify_repl_TBEs) {
        (((*m_storTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
    } else {
        (((*m_storReplTBEs_ptr)).removeEntryFromSlot((*param_tbe).m_storSlot));
    }
    (((*m_replTBEs_ptr)).deallocate((*param_tbe).m_addr));

}
void
Cache_Controller::setDataToBeStates(Cache_TBE* param_tbe)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:789: %s.\n", "assert failure");

}
#endif
;
    if ((*param_tbe).m_dataToBeInvalid) {
        (*param_tbe).m_dataValid = (false);
        (((*param_tbe).m_dataBlkValid).clear());
    }
        if ((*param_tbe).m_dataToBeSharedClean) {
            (*param_tbe).m_dataUnique = (false);
            (*param_tbe).m_dataDirty = (false);
            #ifndef NDEBUG
            if (!(((*param_tbe).m_dataMaybeDirtyUpstream == (false)))) {
                panic("Runtime Error at CHI-cache-funcs.sm:797: %s.\n", "assert failure");

            }
            #endif
            ;
        }
        (*param_tbe).m_dataToBeInvalid = (false);
        (*param_tbe).m_dataToBeSharedClean = (false);

}
void
Cache_Controller::setExpectedForInvSnoop(Cache_TBE* param_tbe, const bool& param_expectCleanWB)
{
#ifndef NDEBUG
if (!(((((*param_tbe).m_expected_snp_resp).hasExpected()) == (false)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:804: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((((*param_tbe).m_dir_sharers).count()) > (0)))) {
    panic("Runtime Error at CHI-cache-funcs.sm:805: %s.\n", "assert failure");

}
#endif
;
(clearExpectedSnpResp(param_tbe));
    if (param_expectCleanWB) {
        (((*param_tbe).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I));
    }
        if ((*param_tbe).m_dataMaybeDirtyUpstream) {
            #ifndef NDEBUG
            if (!((*param_tbe).m_dir_ownerExists)) {
                panic("Runtime Error at CHI-cache-funcs.sm:811: %s.\n", "assert failure");

            }
            #endif
            ;
            (((*param_tbe).m_expected_snp_resp).addExpectedDataType(CHIDataType_SnpRespData_I_PD));
                if (((param_expectCleanWB == (false)) || ((((*param_tbe).m_dir_sharers).count()) > (1)))) {
                    (((*param_tbe).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I));
                }
            } else {
                (((*param_tbe).m_expected_snp_resp).addExpectedRespType(CHIResponseType_SnpResp_I));
            }
            (((*param_tbe).m_expected_snp_resp).setExpectedCount((((*param_tbe).m_dir_sharers).count())));

}
Cache_State
Cache_Controller::makeFinalStateHelper(const Cache_State& param_cs, const Cache_State& param_ds)
{
    if ((param_ds == Cache_State_RSC)) {
            if ((param_cs == Cache_State_UD)) {
                return Cache_State_UD_RSC;
            } else {
                    if ((param_cs == Cache_State_SD)) {
                        return Cache_State_SD_RSC;
                    } else {
                            if ((param_cs == Cache_State_UC)) {
                                return Cache_State_UC_RSC;
                            } else {
                                    if ((param_cs == Cache_State_SC)) {
                                        return Cache_State_SC_RSC;
                                    } else {
                                        return Cache_State_RSC;
                                    }
                                }
                            }
                        }
                    } else {
                            if ((param_ds == Cache_State_RU)) {
                                    if ((param_cs == Cache_State_UD)) {
                                        return Cache_State_UD_RU;
                                    } else {
                                            if ((param_cs == Cache_State_UC)) {
                                                return Cache_State_UC_RU;
                                            } else {
                                                #ifndef NDEBUG
                                                if (!((param_cs != Cache_State_SC))) {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:841: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                #ifndef NDEBUG
                                                if (!((param_cs != Cache_State_SD))) {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:842: %s.\n", "assert failure");

                                                }
                                                #endif
                                                ;
                                                return Cache_State_RU;
                                            }
                                        }
                                    } else {
                                            if ((param_ds == Cache_State_RSD)) {
                                                    if ((param_cs == Cache_State_UD)) {
                                                        return Cache_State_UD_RSD;
                                                    } else {
                                                            if ((param_cs == Cache_State_SD)) {
                                                                return Cache_State_SD_RSD;
                                                            } else {
                                                                #ifndef NDEBUG
                                                                if (!((param_cs == Cache_State_I))) {
                                                                    panic("Runtime Error at CHI-cache-funcs.sm:851: %s.\n", "assert failure");

                                                                }
                                                                #endif
                                                                ;
                                                                return Cache_State_RSD;
                                                            }
                                                        }
                                                    } else {
                                                            if ((param_ds == Cache_State_RUSD)) {
                                                                    if ((param_cs == Cache_State_UD)) {
                                                                        return Cache_State_UD_RSD;
                                                                    } else {
                                                                        #ifndef NDEBUG
                                                                        if (!((param_cs == Cache_State_I))) {
                                                                            panic("Runtime Error at CHI-cache-funcs.sm:858: %s.\n", "assert failure");

                                                                        }
                                                                        #endif
                                                                        ;
                                                                        return Cache_State_RUSD;
                                                                    }
                                                                } else {
                                                                        if ((param_ds == Cache_State_RUSC)) {
                                                                                if ((param_cs == Cache_State_UC)) {
                                                                                    return Cache_State_UC_RSC;
                                                                                } else {
                                                                                        if ((param_cs == Cache_State_UD)) {
                                                                                            return Cache_State_UD_RSC;
                                                                                        } else {
                                                                                            #ifndef NDEBUG
                                                                                            if (!((param_cs == Cache_State_I))) {
                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:867: %s.\n", "assert failure");

                                                                                            }
                                                                                            #endif
                                                                                            ;
                                                                                            return Cache_State_RUSC;
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    #ifndef NDEBUG
                                                                                    if (!((param_ds == Cache_State_I))) {
                                                                                        panic("Runtime Error at CHI-cache-funcs.sm:871: %s.\n", "assert failure");

                                                                                    }
                                                                                    #endif
                                                                                    ;
                                                                                    return param_cs;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }

}
Cache_State
Cache_Controller::makeFinalState(Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry, Cache_DirEntry* param_dir_entry)
{
(setDataToBeStates(param_tbe));
(printTBEState(param_tbe));
Cache_State cache_state
 = Cache_State_I;
Cache_State dir_state
 = Cache_State_I;
    if ((*param_tbe).m_dir_ownerExists) {
        #ifndef NDEBUG
        if (!((param_dir_entry != NULL))) {
            panic("Runtime Error at CHI-cache-funcs.sm:884: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!((*param_tbe).m_dataMaybeDirtyUpstream)) {
            panic("Runtime Error at CHI-cache-funcs.sm:885: %s.\n", "assert failure");

        }
        #endif
        ;
            if ((*param_tbe).m_dir_ownerIsExcl) {
                #ifndef NDEBUG
                if (!(((((*param_tbe).m_dir_sharers).count()) == (1)))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:887: %s.\n", "assert failure");

                }
                #endif
                ;
                dir_state = Cache_State_RU;
            } else {
                #ifndef NDEBUG
                if (!(((((*param_tbe).m_dir_sharers).count()) >= (1)))) {
                    panic("Runtime Error at CHI-cache-funcs.sm:890: %s.\n", "assert failure");

                }
                #endif
                ;
                    if ((*param_tbe).m_dataUnique) {
                        dir_state = Cache_State_RUSD;
                    } else {
                        dir_state = Cache_State_RSD;
                    }
                }
            } else {
                    if (((((*param_tbe).m_dir_sharers).count()) > (0))) {
                        #ifndef NDEBUG
                        if (!((param_dir_entry != NULL))) {
                            panic("Runtime Error at CHI-cache-funcs.sm:898: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                        #ifndef NDEBUG
                        if (!(((*param_tbe).m_dataMaybeDirtyUpstream == (false)))) {
                            panic("Runtime Error at CHI-cache-funcs.sm:899: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                            if ((*param_tbe).m_dataUnique) {
                                dir_state = Cache_State_RUSC;
                            } else {
                                dir_state = Cache_State_RSC;
                            }
                        }
                    }
                        if (((*param_tbe).m_dataValid && (param_cache_entry != NULL))) {
                                if (((*param_tbe).m_dataUnique && (*param_tbe).m_dataDirty)) {
                                        if ((*param_tbe).m_hasUseTimeout) {
                                            cache_state = Cache_State_UD_T;
                                        } else {
                                            cache_state = Cache_State_UD;
                                        }
                                    } else {
                                            if (((*param_tbe).m_dataUnique && ((*param_tbe).m_dataDirty == (false)))) {
                                                cache_state = Cache_State_UC;
                                            } else {
                                                    if ((((*param_tbe).m_dataUnique == (false)) && (*param_tbe).m_dataDirty)) {
                                                        #ifndef NDEBUG
                                                        if (!(m_allow_SD)) {
                                                            panic("Runtime Error at CHI-cache-funcs.sm:917: %s.\n", "assert failure");

                                                        }
                                                        #endif
                                                        ;
                                                        cache_state = Cache_State_SD;
                                                    } else {
                                                        cache_state = Cache_State_SC;
                                                    }
                                                }
                                            }
                                        }
                                        return (makeFinalStateHelper(cache_state, dir_state));

}
Cache_State
Cache_Controller::getNextState(const Addr& param_address)
{
Cache_TBE* tbe
 = (getCurrentActiveTBE(param_address));
#ifndef NDEBUG
if (!((tbe != NULL))) {
    panic("Runtime Error at CHI-cache-funcs.sm:930: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!(((*tbe).m_pendAction == Cache_Event_Final))) {
    panic("Runtime Error at CHI-cache-funcs.sm:931: %s.\n", "assert failure");

}
#endif
;
(*tbe).m_finalState = (makeFinalState(tbe, (getCacheEntry(param_address)), (getDirEntry(param_address))));
#ifndef NDEBUG
if (!(((*tbe).m_finalState != Cache_State_null))) {
    panic("Runtime Error at CHI-cache-funcs.sm:933: %s.\n", "assert failure");

}
#endif
;
return (*tbe).m_finalState;

}
int
Cache_Controller::scLockLatency()
{
return ((*m_sc_lock_multiplier_ptr) * m_sc_lock_base_latency_cy);

}
void
Cache_Controller::scLockIncLatency()
{
(*m_sc_lock_multiplier_ptr) = ((*m_sc_lock_multiplier_ptr) + m_sc_lock_multiplier_inc);
    if (((*m_sc_lock_multiplier_ptr) > m_sc_lock_multiplier_max)) {
        (*m_sc_lock_multiplier_ptr) = m_sc_lock_multiplier_max;
    }
    DPRINTF(LLSC, "CHI-cache-funcs.sm:948: SC lock latency increased to %d cy\n", (scLockLatency()));

}
void
Cache_Controller::scLockDecayLatency()
{
(*m_sc_lock_multiplier_ptr) = ((*m_sc_lock_multiplier_ptr) - m_sc_lock_multiplier_decay);
    if (((*m_sc_lock_multiplier_ptr) < (0))) {
        (*m_sc_lock_multiplier_ptr) = (0);
    }
    DPRINTF(LLSC, "CHI-cache-funcs.sm:957: SC lock latency decayed to %d cy\n", (scLockLatency()));

}
void
Cache_Controller::clearPendingAction(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_snd_pendEv) {
        #ifndef NDEBUG
        if (!(((*param_tbe).m_pendAction == Cache_Event_TX_Data))) {
            panic("Runtime Error at CHI-cache-funcs.sm:963: %s.\n", "assert failure");

        }
        #endif
        ;
    } else {
        (*param_tbe).m_pendAction = Cache_Event_null;
    }

}
bool
Cache_Controller::isReadReqType(const CHIRequestType& param_type)
{
    if (((((param_type == CHIRequestType_Load) || (param_type == CHIRequestType_ReadShared)) || (param_type == CHIRequestType_ReadNotSharedDirty)) || (param_type == CHIRequestType_ReadOnce))) {
        return (true);
    }
    return (false);

}
bool
Cache_Controller::isWriteReqType(const CHIRequestType& param_type)
{
    if ((((((param_type == CHIRequestType_Store) || (param_type == CHIRequestType_StoreLine)) || (param_type == CHIRequestType_WriteUniquePtl)) || (param_type == CHIRequestType_WriteUniqueFull)) || (param_type == CHIRequestType_ReadUnique))) {
        return (true);
    }
    return (false);

}
Cache_Event
Cache_Controller::reqToEvent(const CHIRequestType& param_type, const bool& param_is_prefetch)
{
    if ((param_type == CHIRequestType_Load)) {
            if ((param_is_prefetch == (false))) {
                return Cache_Event_Load;
            } else {
                return Cache_Event_Prefetch;
            }
        } else {
                if ((param_type == CHIRequestType_Store)) {
                    return Cache_Event_Store;
                } else {
                        if ((param_type == CHIRequestType_StoreLine)) {
                            return Cache_Event_Store;
                        } else {
                                if ((param_type == CHIRequestType_ReadShared)) {
                                    return Cache_Event_ReadShared;
                                } else {
                                        if ((param_type == CHIRequestType_ReadNotSharedDirty)) {
                                            return Cache_Event_ReadNotSharedDirty;
                                        } else {
                                                if ((param_type == CHIRequestType_ReadUnique)) {
                                                        if (m_is_HN) {
                                                            return Cache_Event_ReadUnique_PoC;
                                                        } else {
                                                            return Cache_Event_ReadUnique;
                                                        }
                                                    } else {
                                                            if ((param_type == CHIRequestType_CleanUnique)) {
                                                                return Cache_Event_CleanUnique;
                                                            } else {
                                                                    if ((param_type == CHIRequestType_ReadOnce)) {
                                                                        return Cache_Event_ReadOnce;
                                                                    } else {
                                                                            if ((param_type == CHIRequestType_Evict)) {
                                                                                return Cache_Event_Evict;
                                                                            } else {
                                                                                    if ((param_type == CHIRequestType_WriteBackFull)) {
                                                                                        return Cache_Event_WriteBackFull;
                                                                                    } else {
                                                                                            if ((param_type == CHIRequestType_WriteEvictFull)) {
                                                                                                return Cache_Event_WriteEvictFull;
                                                                                            } else {
                                                                                                    if ((param_type == CHIRequestType_WriteCleanFull)) {
                                                                                                        return Cache_Event_WriteCleanFull;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIRequestType_WriteUniquePtl)) {
                                                                                                                    if (m_is_HN) {
                                                                                                                        return Cache_Event_WriteUniquePtl_PoC;
                                                                                                                    } else {
                                                                                                                        return Cache_Event_WriteUnique;
                                                                                                                    }
                                                                                                                } else {
                                                                                                                        if ((param_type == CHIRequestType_WriteUniqueFull)) {
                                                                                                                                if ((m_is_HN && m_alloc_on_writeback)) {
                                                                                                                                    return Cache_Event_WriteUniqueFull_PoC_Alloc;
                                                                                                                                } else {
                                                                                                                                        if (m_is_HN) {
                                                                                                                                            return Cache_Event_WriteUniqueFull_PoC;
                                                                                                                                        } else {
                                                                                                                                            return Cache_Event_WriteUnique;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    panic("Runtime Error at CHI-cache-funcs.sm:1041: %s.\n", ("Invalid CHIRequestType"));
                                                                                                                                    ;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }

}
Cache_Event
Cache_Controller::respToEvent(const CHIResponseType& param_type, Cache_TBE* param_tbe)
{
bool on_hazard
 = ((param_tbe != NULL) && ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard));
    if ((param_type == CHIResponseType_Comp_I)) {
        return Cache_Event_Comp_I;
    } else {
            if ((param_type == CHIResponseType_Comp_UC)) {
                return Cache_Event_Comp_UC;
            } else {
                    if ((param_type == CHIResponseType_Comp_SC)) {
                        return Cache_Event_Comp_SC;
                    } else {
                            if ((param_type == CHIResponseType_CompDBIDResp)) {
                                return Cache_Event_CompDBIDResp;
                            } else {
                                    if ((param_type == CHIResponseType_DBIDResp)) {
                                        return Cache_Event_DBIDResp;
                                    } else {
                                            if ((param_type == CHIResponseType_Comp)) {
                                                return Cache_Event_Comp;
                                            } else {
                                                    if ((param_type == CHIResponseType_CompAck)) {
                                                        return Cache_Event_CompAck;
                                                    } else {
                                                            if ((param_type == CHIResponseType_ReadReceipt)) {
                                                                return Cache_Event_ReadReceipt;
                                                            } else {
                                                                    if ((param_type == CHIResponseType_RespSepData)) {
                                                                        return Cache_Event_RespSepData;
                                                                    } else {
                                                                            if ((param_type == CHIResponseType_SnpResp_I)) {
                                                                                return Cache_Event_SnpResp_I;
                                                                            } else {
                                                                                    if ((param_type == CHIResponseType_SnpResp_I_Fwded_UC)) {
                                                                                        return Cache_Event_SnpResp_I_Fwded_UC;
                                                                                    } else {
                                                                                            if ((param_type == CHIResponseType_SnpResp_I_Fwded_UD_PD)) {
                                                                                                return Cache_Event_SnpResp_I_Fwded_UD_PD;
                                                                                            } else {
                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC)) {
                                                                                                        return Cache_Event_SnpResp_SC;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIResponseType_SnpResp_SC_Fwded_SC)) {
                                                                                                                return Cache_Event_SnpResp_SC_Fwded_SC;
                                                                                                            } else {
                                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC_Fwded_SD_PD)) {
                                                                                                                        return Cache_Event_SnpResp_SC_Fwded_SD_PD;
                                                                                                                    } else {
                                                                                                                            if ((param_type == CHIResponseType_SnpResp_SD_Fwded_I)) {
                                                                                                                                return Cache_Event_SnpResp_SD_Fwded_I;
                                                                                                                            } else {
                                                                                                                                    if ((param_type == CHIResponseType_SnpResp_SC_Fwded_I)) {
                                                                                                                                        return Cache_Event_SnpResp_SC_Fwded_I;
                                                                                                                                    } else {
                                                                                                                                            if ((param_type == CHIResponseType_SnpResp_UD_Fwded_I)) {
                                                                                                                                                return Cache_Event_SnpResp_UD_Fwded_I;
                                                                                                                                            } else {
                                                                                                                                                    if ((param_type == CHIResponseType_SnpResp_UC_Fwded_I)) {
                                                                                                                                                        return Cache_Event_SnpResp_UC_Fwded_I;
                                                                                                                                                    } else {
                                                                                                                                                            if ((param_type == CHIResponseType_RetryAck)) {
                                                                                                                                                                    if (m_is_HN) {
                                                                                                                                                                            if (on_hazard) {
                                                                                                                                                                                return Cache_Event_RetryAck_PoC_Hazard;
                                                                                                                                                                            } else {
                                                                                                                                                                                return Cache_Event_RetryAck_PoC;
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                                if (on_hazard) {
                                                                                                                                                                                    return Cache_Event_RetryAck_Hazard;
                                                                                                                                                                                } else {
                                                                                                                                                                                    return Cache_Event_RetryAck;
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                                if ((param_type == CHIResponseType_PCrdGrant)) {
                                                                                                                                                                                        if (m_is_HN) {
                                                                                                                                                                                                if (on_hazard) {
                                                                                                                                                                                                    return Cache_Event_PCrdGrant_PoC_Hazard;
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    return Cache_Event_PCrdGrant_PoC;
                                                                                                                                                                                                }
                                                                                                                                                                                            } else {
                                                                                                                                                                                                    if (on_hazard) {
                                                                                                                                                                                                        return Cache_Event_PCrdGrant_Hazard;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        return Cache_Event_PCrdGrant;
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            } else {
                                                                                                                                                                                                panic("Runtime Error at CHI-cache-funcs.sm:1114: %s.\n", ("Invalid CHIResponseType"));
                                                                                                                                                                                                ;
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }

}
Cache_Event
Cache_Controller::dataToEvent(const CHIDataType& param_type)
{
    if ((param_type == CHIDataType_CompData_I)) {
        return Cache_Event_CompData_I;
    } else {
            if ((param_type == CHIDataType_CompData_UC)) {
                return Cache_Event_CompData_UC;
            } else {
                    if ((param_type == CHIDataType_CompData_SC)) {
                        return Cache_Event_CompData_SC;
                    } else {
                            if ((param_type == CHIDataType_CompData_UD_PD)) {
                                return Cache_Event_CompData_UD_PD;
                            } else {
                                    if ((param_type == CHIDataType_CompData_SD_PD)) {
                                        return Cache_Event_CompData_SD_PD;
                                    } else {
                                            if ((param_type == CHIDataType_DataSepResp_UC)) {
                                                return Cache_Event_DataSepResp_UC;
                                            } else {
                                                    if ((param_type == CHIDataType_CBWrData_I)) {
                                                        return Cache_Event_CBWrData_I;
                                                    } else {
                                                            if ((param_type == CHIDataType_CBWrData_UC)) {
                                                                return Cache_Event_CBWrData_UC;
                                                            } else {
                                                                    if ((param_type == CHIDataType_CBWrData_SC)) {
                                                                        return Cache_Event_CBWrData_SC;
                                                                    } else {
                                                                            if ((param_type == CHIDataType_CBWrData_UD_PD)) {
                                                                                return Cache_Event_CBWrData_UD_PD;
                                                                            } else {
                                                                                    if ((param_type == CHIDataType_CBWrData_SD_PD)) {
                                                                                        return Cache_Event_CBWrData_SD_PD;
                                                                                    } else {
                                                                                            if ((param_type == CHIDataType_NCBWrData)) {
                                                                                                return Cache_Event_NCBWrData;
                                                                                            } else {
                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_PD)) {
                                                                                                        return Cache_Event_SnpRespData_I_PD;
                                                                                                    } else {
                                                                                                            if ((param_type == CHIDataType_SnpRespData_I)) {
                                                                                                                return Cache_Event_SnpRespData_I;
                                                                                                            } else {
                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SC_PD)) {
                                                                                                                        return Cache_Event_SnpRespData_SC_PD;
                                                                                                                    } else {
                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC)) {
                                                                                                                                return Cache_Event_SnpRespData_SC;
                                                                                                                            } else {
                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SD)) {
                                                                                                                                        return Cache_Event_SnpRespData_SD;
                                                                                                                                    } else {
                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_UC)) {
                                                                                                                                                return Cache_Event_SnpRespData_UC;
                                                                                                                                            } else {
                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_UD)) {
                                                                                                                                                        return Cache_Event_SnpRespData_UD;
                                                                                                                                                    } else {
                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC_Fwded_SC)) {
                                                                                                                                                                return Cache_Event_SnpRespData_SC_Fwded_SC;
                                                                                                                                                            } else {
                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_SC_Fwded_SD_PD)) {
                                                                                                                                                                        return Cache_Event_SnpRespData_SC_Fwded_SD_PD;
                                                                                                                                                                    } else {
                                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_SC_PD_Fwded_SC)) {
                                                                                                                                                                                return Cache_Event_SnpRespData_SC_PD_Fwded_SC;
                                                                                                                                                                            } else {
                                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_Fwded_SD_PD)) {
                                                                                                                                                                                        return Cache_Event_SnpRespData_I_Fwded_SD_PD;
                                                                                                                                                                                    } else {
                                                                                                                                                                                            if ((param_type == CHIDataType_SnpRespData_I_PD_Fwded_SC)) {
                                                                                                                                                                                                return Cache_Event_SnpRespData_I_PD_Fwded_SC;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                    if ((param_type == CHIDataType_SnpRespData_I_Fwded_SC)) {
                                                                                                                                                                                                        return Cache_Event_SnpRespData_I_Fwded_SC;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        panic("Runtime Error at CHI-cache-funcs.sm:1170: %s.\n", ("Invalid CHIDataType"));
                                                                                                                                                                                                        ;
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }

}
Cache_Event
Cache_Controller::snpToEvent(const CHIRequestType& param_type)
{
    if ((param_type == CHIRequestType_SnpCleanInvalid)) {
        return Cache_Event_SnpCleanInvalid;
    } else {
            if ((param_type == CHIRequestType_SnpShared)) {
                return Cache_Event_SnpShared;
            } else {
                    if ((param_type == CHIRequestType_SnpUnique)) {
                        return Cache_Event_SnpUnique;
                    } else {
                            if ((param_type == CHIRequestType_SnpSharedFwd)) {
                                return Cache_Event_SnpSharedFwd;
                            } else {
                                    if ((param_type == CHIRequestType_SnpNotSharedDirtyFwd)) {
                                        return Cache_Event_SnpNotSharedDirtyFwd;
                                    } else {
                                            if ((param_type == CHIRequestType_SnpUniqueFwd)) {
                                                return Cache_Event_SnpUniqueFwd;
                                            } else {
                                                    if ((param_type == CHIRequestType_SnpOnce)) {
                                                        return Cache_Event_SnpOnce;
                                                    } else {
                                                            if ((param_type == CHIRequestType_SnpOnceFwd)) {
                                                                return Cache_Event_SnpOnceFwd;
                                                            } else {
                                                                panic("Runtime Error at CHI-cache-funcs.sm:1192: %s.\n", ("Invalid CHIRequestType"));
                                                                ;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

}
void
Cache_Controller::recordRequestType(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
    if ((param_request_type == Cache_RequestType_DataArrayRead)) {
        (((*m_cache_ptr)).recordRequestType(CacheRequestType_DataArrayRead, param_addr));
    } else {
            if ((param_request_type == Cache_RequestType_DataArrayWrite)) {
                (((*m_cache_ptr)).recordRequestType(CacheRequestType_DataArrayWrite, param_addr));
            } else {
                    if ((param_request_type == Cache_RequestType_TagArrayRead)) {
                        (((*m_cache_ptr)).recordRequestType(CacheRequestType_TagArrayRead, param_addr));
                    } else {
                            if ((param_request_type == Cache_RequestType_TagArrayWrite)) {
                                (((*m_cache_ptr)).recordRequestType(CacheRequestType_TagArrayWrite, param_addr));
                            }
                        }
                    }
                }

}
bool
Cache_Controller::_checkResourceAvailable(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
    if ((param_request_type == Cache_RequestType_DataArrayRead)) {
        return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_DataArray, param_addr));
    } else {
            if ((param_request_type == Cache_RequestType_DataArrayWrite)) {
                return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_DataArray, param_addr));
            } else {
                    if ((param_request_type == Cache_RequestType_TagArrayRead)) {
                        return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_TagArray, param_addr));
                    } else {
                            if ((param_request_type == Cache_RequestType_TagArrayWrite)) {
                                return (((*m_cache_ptr)).checkResourceAvailable(CacheResourceType_TagArray, param_addr));
                            } else {
                                    if ((param_request_type == Cache_RequestType_DestinationAvailable)) {
                                            if (m_throttle_req_on_retry) {
                                                MachineID dest
                                                 = (mapAddressToDownstreamMachine(param_addr));
                                                DPRINTF(RubySlicc, "CHI-cache-funcs.sm:1234: Checking %s for addr %#x dest %s\n", param_request_type, param_addr, dest);
                                                return ((((*m_destsWaitingRetry_ptr)).isElement(dest)) == (false));
                                            } else {
                                                return (true);
                                            }
                                        } else {
                                                if ((param_request_type == Cache_RequestType_ReplTBEAvailable)) {
                                                    return (m_unify_repl_TBEs || (((*m_storReplTBEs_ptr)).areNSlotsAvailable((1))));
                                                } else {
                                                    panic("Runtime Error at CHI-cache-funcs.sm:1244: %s.\n", ("Invalid RequestType type in checkResourceAvailable"));
                                                    ;
                                                    return (true);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

}
bool
Cache_Controller::checkResourceAvailable(const Cache_RequestType& param_request_type, const Addr& param_addr)
{
bool avail
 = (_checkResourceAvailable(param_request_type, param_addr));
    if ((avail == (false))) {
        DPRINTF(RubySlicc, "CHI-cache-funcs.sm:1252: Resource %s not available for addr: %#x\n", param_request_type, param_addr);
    }
    return avail;

}
bool
Cache_Controller::rspInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:88: %s.\n", ("rspInPort must never stall\n"));
;
return (false);

}
bool
Cache_Controller::datInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:107: %s.\n", ("datInPort must never stall\n"));
;
return (false);

}
bool
Cache_Controller::snpRdyPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:134: %s.\n", ("snpRdyPort must never stall\n"));
;
return (false);

}
void
Cache_Controller::wakeupPendingSnps(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_snp) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_snpRdy_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_snp = (false);
    }

}
bool
Cache_Controller::retryTriggerInPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:186: Retry trigger queue resource stall\n");
(((*m_retryTriggerQueue_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
bool
Cache_Controller::triggerInPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:215: Trigger queue resource stall\n");
(((*m_triggerQueue_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
Cache_Controller::wakeupPendingTgrs(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_tgr) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_triggerQueue_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_tgr = (false);
    }

}
bool
Cache_Controller::reqRdyPort_rsc_stall_handler()
{
DPRINTF(RubySlicc, "CHI-cache-ports.sm:295: ReqRdy queue resource stall\n");
(((*m_reqRdy_ptr)).recycle((clockEdge()), (cyclesToTicks(m_stall_recycle_lat))));
return (true);

}
void
Cache_Controller::wakeupPendingReqs(Cache_TBE* param_tbe)
{
    if ((*param_tbe).m_wakeup_pending_req) {
        Addr addr
         = (*param_tbe).m_addr;
                wakeUpBuffer(&((*m_reqRdy_ptr)), addr);
                
        (*param_tbe).m_wakeup_pending_req = (false);
    }

}
bool
Cache_Controller::reqInPort_rsc_stall_handler()
{
panic("Runtime Error at CHI-cache-ports.sm:325: %s.\n", ("reqInPort must never stall\n"));
;
return (false);

}
void
Cache_Controller::processNextState(const Addr& param_address, Cache_TBE* param_tbe, Cache_CacheEntry* param_cache_entry)
{
#ifndef NDEBUG
if (!((param_tbe != NULL))) {
    panic("Runtime Error at CHI-cache-ports.sm:356: %s.\n", "assert failure");

}
#endif
;
DPRINTF(RubySlicc, "CHI-cache-ports.sm:357: GoToNextState expected_req_resp=%d expected_snp_resp=%d snd_pendEv=%d snd_pendBytes=%d\n", (((*param_tbe).m_expected_req_resp).expected()), (((*param_tbe).m_expected_snp_resp).expected()), (*param_tbe).m_snd_pendEv, (((*param_tbe).m_snd_pendBytes).count()));
bool has_nb_trigger
 = ((((((*param_tbe).m_actions).empty()) == (false)) && (((*param_tbe).m_actions).frontNB())) && ((*param_tbe).m_snd_pendEv == (false)));
int expected_msgs
 = (((((*param_tbe).m_expected_req_resp).expected()) + (((*param_tbe).m_expected_snp_resp).expected())) + (((*param_tbe).m_snd_pendBytes).count()));
    if ((((*param_tbe).m_pendAction == Cache_Event_null) && ((expected_msgs == (0)) || has_nb_trigger))) {
        Cycles trigger_latency
         = (intToCycles((0)));
            if (((*param_tbe).m_delayNextAction > (curTick()))) {
                trigger_latency = ((ticksToCycles((*param_tbe).m_delayNextAction)) - (ticksToCycles((curTick()))));
                (*param_tbe).m_delayNextAction = (intToTick((0)));
            }
            (*param_tbe).m_pendAction = Cache_Event_null;
                if ((((*param_tbe).m_actions).empty())) {
                    (*param_tbe).m_pendAction = Cache_Event_Final;
                } else {
                    (*param_tbe).m_pendAction = (((*param_tbe).m_actions).front());
                    (((*param_tbe).m_actions).pop());
                }
                #ifndef NDEBUG
                if (!(((*param_tbe).m_pendAction != Cache_Event_null))) {
                    panic("Runtime Error at CHI-cache-ports.sm:386: %s.\n", "assert failure");

                }
                #endif
                ;
                {
                    std::shared_ptr<Cache_TriggerMsg> out_msg = std::make_shared<Cache_TriggerMsg>(clockEdge());
                    (*out_msg).m_addr = (*param_tbe).m_addr;
                    (*out_msg).m_from_hazard = ((*param_tbe).m_is_req_hazard || (*param_tbe).m_is_repl_hazard);
                    ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(trigger_latency)));
                }
            }
            (printTBEState(param_tbe));
            (wakeupPendingSnps(param_tbe));

}
int
Cache_Controller::functionalWriteBuffers(PacketPtr& pkt)
{
    int num_functional_writes = 0;
num_functional_writes += m_reqOut_ptr->functionalWrite(pkt);
num_functional_writes += m_snpOut_ptr->functionalWrite(pkt);
num_functional_writes += m_rspOut_ptr->functionalWrite(pkt);
num_functional_writes += m_datOut_ptr->functionalWrite(pkt);
num_functional_writes += m_reqIn_ptr->functionalWrite(pkt);
num_functional_writes += m_snpIn_ptr->functionalWrite(pkt);
num_functional_writes += m_rspIn_ptr->functionalWrite(pkt);
num_functional_writes += m_datIn_ptr->functionalWrite(pkt);
num_functional_writes += m_mandatoryQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_triggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_retryTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_reqRdy_ptr->functionalWrite(pkt);
num_functional_writes += m_snpRdy_ptr->functionalWrite(pkt);
num_functional_writes += m_replTriggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_prefetchQueue_ptr->functionalWrite(pkt);
    return num_functional_writes;
}
bool
Cache_Controller::functionalReadBuffers(PacketPtr& pkt)
{
if (m_reqOut_ptr->functionalRead(pkt)) return true;
if (m_snpOut_ptr->functionalRead(pkt)) return true;
if (m_rspOut_ptr->functionalRead(pkt)) return true;
if (m_datOut_ptr->functionalRead(pkt)) return true;
if (m_reqIn_ptr->functionalRead(pkt)) return true;
if (m_snpIn_ptr->functionalRead(pkt)) return true;
if (m_rspIn_ptr->functionalRead(pkt)) return true;
if (m_datIn_ptr->functionalRead(pkt)) return true;
if (m_mandatoryQueue_ptr->functionalRead(pkt)) return true;
if (m_triggerQueue_ptr->functionalRead(pkt)) return true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_reqRdy_ptr->functionalRead(pkt)) return true;
if (m_snpRdy_ptr->functionalRead(pkt)) return true;
if (m_replTriggerQueue_ptr->functionalRead(pkt)) return true;
if (m_prefetchQueue_ptr->functionalRead(pkt)) return true;
    return false;
}

bool
Cache_Controller::functionalReadBuffers(PacketPtr& pkt, WriteMask &mask)
{
    bool read = false;
if (m_reqOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_datOut_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_rspIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_datIn_ptr->functionalRead(pkt, mask)) read = true;
if (m_mandatoryQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_triggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_retryTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_reqRdy_ptr->functionalRead(pkt, mask)) read = true;
if (m_snpRdy_ptr->functionalRead(pkt, mask)) read = true;
if (m_replTriggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_prefetchQueue_ptr->functionalRead(pkt, mask)) read = true;
    return read;
}

} // namespace ruby
} // namespace gem5
