/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /home/sean/gem5-rtl/src/mem/slicc/symbols/StateMachine.py:1359
 */

// Cache: Cache coherency protocol

#include <sys/types.h>
#include <unistd.h>

#include <cassert>
#include <typeinfo>

#include "base/logging.hh"

#include "debug/RubySlicc.hh"
#include "debug/LLSC.hh"
#include "debug/RubyGenerated.hh"
#include "mem/ruby/protocol/Cache_Controller.hh"
#include "mem/ruby/protocol/Cache_Event.hh"
#include "mem/ruby/protocol/Cache_State.hh"

#include "mem/ruby/protocol/Cache_RequestType.hh"
#include "mem/ruby/protocol/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#include "mem/ruby/slicc_interface/RubySlicc_includes.hh"
namespace gem5
{

namespace ruby
{

void
Cache_Controller::wakeup()
{
    if (getMemReqQueue() && getMemReqQueue()->isReady(clockEdge())) {
        serviceMemoryQueue();
    }

    int counter = 0;
    while (true) {
        unsigned char rejected[12];
        memset(rejected, 0, sizeof(unsigned char)*12);
        // Some cases will put us into an infinite loop without this limit
        assert(counter <= m_transitions_per_cycle);
        if (counter == m_transitions_per_cycle) {
            // Count how often we are fully utilized
            stats.fullyBusyCycles++;

            // Wakeup in another cycle and try again
            scheduleEvent(Cycles(1));
            break;
        }
            // CacheInPort useTimerTable_in
            m_cur_in_port = 11;
            try {
                            if ((((*m_useTimerTable_ptr)).isReady((clockEdge())))) {
                                Addr readyAddress
                                 = (((*m_useTimerTable_ptr)).nextAddress());
                                {

                                    TransitionResult result = doTransition(Cache_Event_UseTimeout, (getCacheEntry(readyAddress)), (getCurrentActiveTBE(readyAddress)), readyAddress);

                                    if (result == TransitionResult_Valid) {
                                        counter++;
                                        continue; // Check the first port again
                                    } else if (result == TransitionResult_ResourceStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    } else if (result == TransitionResult_ProtocolStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    }

                                }
                                ;
                            }
                        } catch (const RejectException & e) {
                            rejected[0]++;
                        }
            // CacheInPort rspInPort
            m_cur_in_port = 10;
            try {
                            if ((((*m_rspIn_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const CHIResponseMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const CHIResponseMsg *>(((*m_rspIn_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                Cache_TBE* tbe
                                 = (getCurrentActiveTBE(((*in_msg_ptr)).m_addr));
                                {

                                    TransitionResult result = doTransition((respToEvent(((*in_msg_ptr)).m_type, tbe)), (getCacheEntry(((*in_msg_ptr)).m_addr)), tbe, ((*in_msg_ptr)).m_addr);

                                    if (result == TransitionResult_Valid) {
                                        counter++;
                                        continue; // Check the first port again
                                    } else if (result == TransitionResult_ResourceStall) {

                                        if (rspInPort_rsc_stall_handler()) {
                                            counter++;
                                            continue; // Check the first port again
                                        } else {
                                            scheduleEvent(Cycles(1));
                                            // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                        }

                                    } else if (result == TransitionResult_ProtocolStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    }

                                }
                                ;
                                }
                            }
                        } catch (const RejectException & e) {
                            rejected[1]++;
                        }
            // CacheInPort datInPort
            m_cur_in_port = 9;
            try {
                            if ((((*m_datIn_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const CHIDataMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const CHIDataMsg *>(((*m_datIn_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                #ifndef NDEBUG
                                if (!(((((((*in_msg_ptr)).m_bitMask).count()) <= m_data_channel_size) && (((((*in_msg_ptr)).m_bitMask).count()) > (0))))) {
                                    panic("Runtime Error at CHI-cache-ports.sm:100: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                {

                                    TransitionResult result = doTransition((dataToEvent(((*in_msg_ptr)).m_type)), (getCacheEntry(((*in_msg_ptr)).m_addr)), (getCurrentActiveTBE(((*in_msg_ptr)).m_addr)), ((*in_msg_ptr)).m_addr);

                                    if (result == TransitionResult_Valid) {
                                        counter++;
                                        continue; // Check the first port again
                                    } else if (result == TransitionResult_ResourceStall) {

                                        if (datInPort_rsc_stall_handler()) {
                                            counter++;
                                            continue; // Check the first port again
                                        } else {
                                            scheduleEvent(Cycles(1));
                                            // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                        }

                                    } else if (result == TransitionResult_ProtocolStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    }

                                }
                                ;
                                }
                            }
                        } catch (const RejectException & e) {
                            rejected[2]++;
                        }
            // CacheInPort snpRdyPort
            m_cur_in_port = 8;
            try {
                            if ((((*m_snpRdy_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpRdy_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                #ifndef NDEBUG
                                if (!((((*in_msg_ptr)).m_allowRetry == (false)))) {
                                    panic("Runtime Error at CHI-cache-ports.sm:118: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                Cache_TBE* tbe
                                 = (getCurrentActiveTBE(((*in_msg_ptr)).m_addr));
                                    if (((tbe != NULL) && (*tbe).m_hasUseTimeout)) {
                                        {

                                            TransitionResult result = doTransition(Cache_Event_SnpStalled, (getCacheEntry(((*in_msg_ptr)).m_addr)), tbe, ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                if (snpRdyPort_rsc_stall_handler()) {
                                                    counter++;
                                                    continue; // Check the first port again
                                                } else {
                                                    scheduleEvent(Cycles(1));
                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                }

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                    } else {
                                        {

                                            TransitionResult result = doTransition((snpToEvent(((*in_msg_ptr)).m_type)), (getCacheEntry(((*in_msg_ptr)).m_addr)), tbe, ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                if (snpRdyPort_rsc_stall_handler()) {
                                                    counter++;
                                                    continue; // Check the first port again
                                                } else {
                                                    scheduleEvent(Cycles(1));
                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                }

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                    }
                                    }
                                }
                        } catch (const RejectException & e) {
                            rejected[3]++;
                        }
            // CacheInPort snpInPort
            m_cur_in_port = 7;
            try {
                            if ((((*m_snpIn_ptr)).isReady((clockEdge())))) {
                                #ifndef NDEBUG
                                if (!((m_is_HN == (false)))) {
                                    panic("Runtime Error at CHI-cache-ports.sm:151: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_snpIn_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                #ifndef NDEBUG
                                if (!((((*in_msg_ptr)).m_allowRetry == (false)))) {
                                    panic("Runtime Error at CHI-cache-ports.sm:154: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                {

                                    TransitionResult result = doTransition(Cache_Event_AllocSnoop, (getCacheEntry(((*in_msg_ptr)).m_addr)), (getCurrentActiveTBE(((*in_msg_ptr)).m_addr)), ((*in_msg_ptr)).m_addr);

                                    if (result == TransitionResult_Valid) {
                                        counter++;
                                        continue; // Check the first port again
                                    } else if (result == TransitionResult_ResourceStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    } else if (result == TransitionResult_ProtocolStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    }

                                }
                                ;
                                }
                            }
                        } catch (const RejectException & e) {
                            rejected[4]++;
                        }
            // CacheInPort retryTriggerInPort
            m_cur_in_port = 6;
            try {
                            if ((((*m_retryTriggerQueue_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const Cache_RetryTriggerMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const Cache_RetryTriggerMsg *>(((*m_retryTriggerQueue_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                Cache_Event ev
                                 = ((*in_msg_ptr)).m_event;
                                Cache_TBE* tbe
                                 = (getCurrentActiveTBE(((*in_msg_ptr)).m_addr));
                                #ifndef NDEBUG
                                if (!((((ev == Cache_Event_SendRetryAck) || (ev == Cache_Event_SendPCrdGrant)) || (ev == Cache_Event_DoRetry)))) {
                                    panic("Runtime Error at CHI-cache-ports.sm:174: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                    if ((ev == Cache_Event_DoRetry)) {
                                        #ifndef NDEBUG
                                        if (!((tbe != NULL))) {
                                            panic("Runtime Error at CHI-cache-ports.sm:176: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                            if (((*tbe).m_is_req_hazard || (*tbe).m_is_repl_hazard)) {
                                                ev = Cache_Event_DoRetry_Hazard;
                                            }
                                        }
                                        {

                                            TransitionResult result = doTransition(ev, (getCacheEntry(((*in_msg_ptr)).m_addr)), tbe, ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                if (retryTriggerInPort_rsc_stall_handler()) {
                                                    counter++;
                                                    continue; // Check the first port again
                                                } else {
                                                    scheduleEvent(Cycles(1));
                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                }

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                        }
                                    }
                        } catch (const RejectException & e) {
                            rejected[5]++;
                        }
            // CacheInPort triggerInPort
            m_cur_in_port = 5;
            try {
                            if ((((*m_triggerQueue_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const Cache_TriggerMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const Cache_TriggerMsg *>(((*m_triggerQueue_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                Cache_TBE* tbe
                                 = (getCurrentActiveTBE(((*in_msg_ptr)).m_addr));
                                #ifndef NDEBUG
                                if (!((tbe != NULL))) {
                                    panic("Runtime Error at CHI-cache-ports.sm:199: %s.\n", "assert failure");

                                }
                                #endif
                                ;
                                    if ((((*in_msg_ptr)).m_from_hazard != ((*tbe).m_is_req_hazard || (*tbe).m_is_repl_hazard))) {
                                        #ifndef NDEBUG
                                        if (!((((*in_msg_ptr)).m_from_hazard == (false)))) {
                                            panic("Runtime Error at CHI-cache-ports.sm:204: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        #ifndef NDEBUG
                                        if (!(((*tbe).m_is_req_hazard || (*tbe).m_is_repl_hazard))) {
                                            panic("Runtime Error at CHI-cache-ports.sm:205: %s.\n", "assert failure");

                                        }
                                        #endif
                                        ;
                                        {

                                            TransitionResult result = doTransition(Cache_Event_ActionStalledOnHazard, (getCacheEntry(((*in_msg_ptr)).m_addr)), tbe, ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                if (triggerInPort_rsc_stall_handler()) {
                                                    counter++;
                                                    continue; // Check the first port again
                                                } else {
                                                    scheduleEvent(Cycles(1));
                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                }

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                    } else {
                                        {

                                            TransitionResult result = doTransition((*tbe).m_pendAction, (getCacheEntry(((*in_msg_ptr)).m_addr)), tbe, ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                if (triggerInPort_rsc_stall_handler()) {
                                                    counter++;
                                                    continue; // Check the first port again
                                                } else {
                                                    scheduleEvent(Cycles(1));
                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                }

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                    }
                                    }
                                }
                        } catch (const RejectException & e) {
                            rejected[6]++;
                        }
            // CacheInPort replTriggerInPort
            m_cur_in_port = 4;
            try {
                            if ((((*m_replTriggerQueue_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const Cache_ReplacementMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const Cache_ReplacementMsg *>(((*m_replTriggerQueue_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                Cache_TBE* tbe
                                 = (getCurrentActiveTBE(((*in_msg_ptr)).m_addr));
                                Cache_CacheEntry* cache_entry
                                 = (getCacheEntry(((*in_msg_ptr)).m_addr));
                                Cache_Event trigger
                                 = Cache_Event_null;
                                    if (((cache_entry != NULL) && (((upstreamHasUnique((*cache_entry).m_state)) && m_dealloc_backinv_unique) || ((upstreamHasShared((*cache_entry).m_state)) && m_dealloc_backinv_shared)))) {
                                        trigger = Cache_Event_Global_Eviction;
                                    } else {
                                            if (m_is_HN) {
                                                trigger = Cache_Event_LocalHN_Eviction;
                                            } else {
                                                trigger = Cache_Event_Local_Eviction;
                                            }
                                        }
                                        {

                                            TransitionResult result = doTransition(trigger, cache_entry, tbe, ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                        }
                                    }
                        } catch (const RejectException & e) {
                            rejected[7]++;
                        }
            // CacheInPort reqRdyPort
            m_cur_in_port = 3;
            try {
                            if ((((*m_reqRdy_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqRdy_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                Cache_CacheEntry* cache_entry
                                 = (getCacheEntry(((*in_msg_ptr)).m_addr));
                                Cache_TBE* tbe
                                 = (getCurrentActiveTBE(((*in_msg_ptr)).m_addr));
                                Cache_DirEntry* dir_entry
                                 = (getDirEntry(((*in_msg_ptr)).m_addr));
                                    if ((((*in_msg_ptr)).m_type == CHIRequestType_WriteBackFull)) {
                                            if ((((dir_entry == NULL) || ((*dir_entry).m_ownerExists == (false))) || ((*dir_entry).m_owner != ((*in_msg_ptr)).m_requestor))) {
                                                {

                                                    TransitionResult result = doTransition(Cache_Event_WriteBackFull_Stale, cache_entry, tbe, ((*in_msg_ptr)).m_addr);

                                                    if (result == TransitionResult_Valid) {
                                                        counter++;
                                                        continue; // Check the first port again
                                                    } else if (result == TransitionResult_ResourceStall) {

                                                        if (reqRdyPort_rsc_stall_handler()) {
                                                            counter++;
                                                            continue; // Check the first port again
                                                        } else {
                                                            scheduleEvent(Cycles(1));
                                                            // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                        }

                                                    } else if (result == TransitionResult_ProtocolStall) {

                                                        scheduleEvent(Cycles(1));
                                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                                    }

                                                }
                                                ;
                                            }
                                        } else {
                                                if ((((*in_msg_ptr)).m_type == CHIRequestType_WriteEvictFull)) {
                                                        if (((((dir_entry == NULL) || ((*dir_entry).m_ownerExists == (false))) || ((*dir_entry).m_ownerIsExcl == (false))) || ((*dir_entry).m_owner != ((*in_msg_ptr)).m_requestor))) {
                                                            {

                                                                TransitionResult result = doTransition(Cache_Event_WriteEvictFull_Stale, cache_entry, tbe, ((*in_msg_ptr)).m_addr);

                                                                if (result == TransitionResult_Valid) {
                                                                    counter++;
                                                                    continue; // Check the first port again
                                                                } else if (result == TransitionResult_ResourceStall) {

                                                                    if (reqRdyPort_rsc_stall_handler()) {
                                                                        counter++;
                                                                        continue; // Check the first port again
                                                                    } else {
                                                                        scheduleEvent(Cycles(1));
                                                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                                    }

                                                                } else if (result == TransitionResult_ProtocolStall) {

                                                                    scheduleEvent(Cycles(1));
                                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                                                }

                                                            }
                                                            ;
                                                        }
                                                    } else {
                                                            if ((((*in_msg_ptr)).m_type == CHIRequestType_WriteCleanFull)) {
                                                                    if (((((dir_entry == NULL) || ((*dir_entry).m_ownerExists == (false))) || ((*dir_entry).m_ownerIsExcl == (false))) || ((*dir_entry).m_owner != ((*in_msg_ptr)).m_requestor))) {
                                                                        {

                                                                            TransitionResult result = doTransition(Cache_Event_WriteCleanFull_Stale, cache_entry, tbe, ((*in_msg_ptr)).m_addr);

                                                                            if (result == TransitionResult_Valid) {
                                                                                counter++;
                                                                                continue; // Check the first port again
                                                                            } else if (result == TransitionResult_ResourceStall) {

                                                                                if (reqRdyPort_rsc_stall_handler()) {
                                                                                    counter++;
                                                                                    continue; // Check the first port again
                                                                                } else {
                                                                                    scheduleEvent(Cycles(1));
                                                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                                                }

                                                                            } else if (result == TransitionResult_ProtocolStall) {

                                                                                scheduleEvent(Cycles(1));
                                                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                                                            }

                                                                        }
                                                                        ;
                                                                    }
                                                                } else {
                                                                        if ((((*in_msg_ptr)).m_type == CHIRequestType_Evict)) {
                                                                                if (((dir_entry == NULL) || ((((*dir_entry).m_sharers).isElement(((*in_msg_ptr)).m_requestor)) == (false)))) {
                                                                                    {

                                                                                        TransitionResult result = doTransition(Cache_Event_Evict_Stale, cache_entry, tbe, ((*in_msg_ptr)).m_addr);

                                                                                        if (result == TransitionResult_Valid) {
                                                                                            counter++;
                                                                                            continue; // Check the first port again
                                                                                        } else if (result == TransitionResult_ResourceStall) {

                                                                                            if (reqRdyPort_rsc_stall_handler()) {
                                                                                                counter++;
                                                                                                continue; // Check the first port again
                                                                                            } else {
                                                                                                scheduleEvent(Cycles(1));
                                                                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                                                            }

                                                                                        } else if (result == TransitionResult_ProtocolStall) {

                                                                                            scheduleEvent(Cycles(1));
                                                                                            // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                                                                        }

                                                                                    }
                                                                                    ;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                {

                                                                    TransitionResult result = doTransition((reqToEvent(((*in_msg_ptr)).m_type, ((*in_msg_ptr)).m_is_local_pf)), cache_entry, tbe, ((*in_msg_ptr)).m_addr);

                                                                    if (result == TransitionResult_Valid) {
                                                                        counter++;
                                                                        continue; // Check the first port again
                                                                    } else if (result == TransitionResult_ResourceStall) {

                                                                        if (reqRdyPort_rsc_stall_handler()) {
                                                                            counter++;
                                                                            continue; // Check the first port again
                                                                        } else {
                                                                            scheduleEvent(Cycles(1));
                                                                            // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                                        }

                                                                    } else if (result == TransitionResult_ProtocolStall) {

                                                                        scheduleEvent(Cycles(1));
                                                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                                                    }

                                                                }
                                                                ;
                                                                }
                                                            }
                        } catch (const RejectException & e) {
                            rejected[8]++;
                        }
            // CacheInPort reqInPort
            m_cur_in_port = 2;
            try {
                            if ((((*m_reqIn_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const CHIRequestMsg* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const CHIRequestMsg *>(((*m_reqIn_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                    if (((*in_msg_ptr)).m_allowRetry) {
                                        {

                                            TransitionResult result = doTransition(Cache_Event_AllocRequest, (getCacheEntry(((*in_msg_ptr)).m_addr)), (getCurrentActiveTBE(((*in_msg_ptr)).m_addr)), ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                if (reqInPort_rsc_stall_handler()) {
                                                    counter++;
                                                    continue; // Check the first port again
                                                } else {
                                                    scheduleEvent(Cycles(1));
                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                }

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                    } else {
                                        {

                                            TransitionResult result = doTransition(Cache_Event_AllocRequestWithCredit, (getCacheEntry(((*in_msg_ptr)).m_addr)), (getCurrentActiveTBE(((*in_msg_ptr)).m_addr)), ((*in_msg_ptr)).m_addr);

                                            if (result == TransitionResult_Valid) {
                                                counter++;
                                                continue; // Check the first port again
                                            } else if (result == TransitionResult_ResourceStall) {

                                                if (reqInPort_rsc_stall_handler()) {
                                                    counter++;
                                                    continue; // Check the first port again
                                                } else {
                                                    scheduleEvent(Cycles(1));
                                                    // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)
                                                }

                                            } else if (result == TransitionResult_ProtocolStall) {

                                                scheduleEvent(Cycles(1));
                                                // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                            }

                                        }
                                        ;
                                    }
                                    }
                                }
                        } catch (const RejectException & e) {
                            rejected[9]++;
                        }
            // CacheInPort seqInPort
            m_cur_in_port = 1;
            try {
                            if ((((*m_mandatoryQueue_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const RubyRequest* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_mandatoryQueue_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                {

                                    TransitionResult result = doTransition(Cache_Event_AllocSeqRequest, (getCacheEntry(((*in_msg_ptr)).m_LineAddress)), (getCurrentActiveTBE(((*in_msg_ptr)).m_LineAddress)), ((*in_msg_ptr)).m_LineAddress);

                                    if (result == TransitionResult_Valid) {
                                        counter++;
                                        continue; // Check the first port again
                                    } else if (result == TransitionResult_ResourceStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    } else if (result == TransitionResult_ProtocolStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    }

                                }
                                ;
                                }
                            }
                        } catch (const RejectException & e) {
                            rejected[10]++;
                        }
            // CacheInPort pfInPort
            m_cur_in_port = 0;
            try {
                            if ((((*m_prefetchQueue_ptr)).isReady((clockEdge())))) {
                                (printResources());
                                {
                                    // Declare message
                                    GEM5_VAR_USED const RubyRequest* in_msg_ptr;
                                    in_msg_ptr = dynamic_cast<const RubyRequest *>(((*m_prefetchQueue_ptr)).peek());
                                    if (in_msg_ptr == NULL) {
                                        // If the cast fails, this is the wrong inport (wrong message type).
                                        // Throw an exception, and the caller will decide to either try a
                                        // different inport or punt.
                                        throw RejectException();
                                    }
                                {

                                    TransitionResult result = doTransition(Cache_Event_AllocPfRequest, (getCacheEntry(((*in_msg_ptr)).m_LineAddress)), (getCurrentActiveTBE(((*in_msg_ptr)).m_LineAddress)), ((*in_msg_ptr)).m_LineAddress);

                                    if (result == TransitionResult_Valid) {
                                        counter++;
                                        continue; // Check the first port again
                                    } else if (result == TransitionResult_ResourceStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    } else if (result == TransitionResult_ProtocolStall) {

                                        scheduleEvent(Cycles(1));
                                        // Cannot do anything with this transition, go check next doable transition (mostly likely of next port)

                                    }

                                }
                                ;
                                }
                            }
                        } catch (const RejectException & e) {
                            rejected[11]++;
                        }
        // If we got this far, we have nothing left todo or something went
        // wrong
        break;
    }
}

} // namespace ruby
} // namespace gem5
